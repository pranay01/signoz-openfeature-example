{
  "version": 3,
  "sources": ["../../src/provider/provider.ts", "../../src/provider/no-op-provider.ts", "../../src/provider/in-memory-provider/in-memory-provider.ts", "../../src/provider/in-memory-provider/variant-not-found-error.ts", "../../src/open-feature.ts", "../../src/client/internal/open-feature-client.ts", "../../src/events/open-feature-event-emitter.ts", "../../src/events/events.ts", "../../src/transaction-context/no-op-transaction-context-propagator.ts", "../../src/transaction-context/async-local-storage-transaction-context-propagator.ts", "../../src/index.ts"],
  "sourcesContent": ["import { CommonProvider, EvaluationContext, JsonValue, Logger, ResolutionDetails, ServerProviderStatus } from '@openfeature/core';\nimport { Hook } from '../hooks';\n\nexport { ServerProviderStatus as ProviderStatus };\n\n/**\n * Interface that providers must implement to resolve flag values for their particular\n * backend or vendor.\n *\n * Implementation for resolving all the required flag types must be defined.\n */\nexport interface Provider extends CommonProvider<ServerProviderStatus> {\n  /**\n   * A provider hook exposes a mechanism for provider authors to register hooks\n   * to tap into various stages of the flag evaluation lifecycle. These hooks can\n   * be used to perform side effects and mutate the context for purposes of the\n   * provider. Provider hooks are not configured or controlled by the application author.\n   */\n  readonly hooks?: Hook[];\n\n  /**\n   * Resolve a boolean flag and its evaluation details.\n   */\n  resolveBooleanEvaluation(\n    flagKey: string,\n    defaultValue: boolean,\n    context: EvaluationContext,\n    logger: Logger,\n  ): Promise<ResolutionDetails<boolean>>;\n\n  /**\n   * Resolve a string flag and its evaluation details.\n   */\n  resolveStringEvaluation(\n    flagKey: string,\n    defaultValue: string,\n    context: EvaluationContext,\n    logger: Logger,\n  ): Promise<ResolutionDetails<string>>;\n\n  /**\n   * Resolve a numeric flag and its evaluation details.\n   */\n  resolveNumberEvaluation(\n    flagKey: string,\n    defaultValue: number,\n    context: EvaluationContext,\n    logger: Logger,\n  ): Promise<ResolutionDetails<number>>;\n\n  /**\n   * Resolve and parse an object flag and its evaluation details.\n   */\n  resolveObjectEvaluation<T extends JsonValue>(\n    flagKey: string,\n    defaultValue: T,\n    context: EvaluationContext,\n    logger: Logger,\n  ): Promise<ResolutionDetails<T>>;\n}\n", "import { JsonValue, ResolutionDetails } from '@openfeature/core';\nimport { Provider } from './provider';\n\nconst REASON_NO_OP = 'No-op';\n\n/**\n * The No-op provider is set by default, and simply always returns the default value.\n */\nclass NoopFeatureProvider implements Provider {\n  readonly metadata = {\n    name: 'No-op Provider',\n  } as const;\n\n  resolveBooleanEvaluation(_: string, defaultValue: boolean): Promise<ResolutionDetails<boolean>> {\n    return this.noOp(defaultValue);\n  }\n\n  resolveStringEvaluation(_: string, defaultValue: string): Promise<ResolutionDetails<string>> {\n    return this.noOp(defaultValue);\n  }\n\n  resolveNumberEvaluation(_: string, defaultValue: number): Promise<ResolutionDetails<number>> {\n    return this.noOp(defaultValue);\n  }\n\n  resolveObjectEvaluation<T extends JsonValue>(_: string, defaultValue: T): Promise<ResolutionDetails<T>> {\n    return this.noOp<T>(defaultValue);\n  }\n\n  private noOp<T>(defaultValue: T) {\n    return Promise.resolve({\n      value: defaultValue,\n      reason: REASON_NO_OP,\n    });\n  }\n}\n\nexport const NOOP_PROVIDER = new NoopFeatureProvider();\n", "import {\n  EvaluationContext,\n  FlagNotFoundError,\n  FlagValueType,\n  GeneralError,\n  JsonValue,\n  Logger,\n  OpenFeatureError,\n  ResolutionDetails,\n  StandardResolutionReasons,\n  TypeMismatchError\n} from '@openfeature/core';\nimport { Provider } from '../provider';\nimport { Flag, FlagConfiguration } from './flag-configuration';\nimport { VariantFoundError } from './variant-not-found-error';\nimport { OpenFeatureEventEmitter, ProviderEvents } from '../..';\n\n/**\n * A simple OpenFeature provider intended for demos and as a test stub.\n */\nexport class InMemoryProvider implements Provider {\n  public readonly events = new OpenFeatureEventEmitter();\n  public readonly runsOn = 'server';\n  readonly metadata = {\n    name: 'in-memory',\n  } as const;\n  private _flagConfiguration: FlagConfiguration;\n\n  constructor(flagConfiguration: FlagConfiguration = {}) {\n    this._flagConfiguration = { ...flagConfiguration };\n  }\n\n  /**\n   * Overwrites the configured flags.\n   * @param { FlagConfiguration } flagConfiguration new flag configuration\n   */\n  putConfiguration(flagConfiguration: FlagConfiguration) {\n    const flagsChanged = Object.entries(flagConfiguration)\n      .filter(([key, value]) => this._flagConfiguration[key] !== value)\n      .map(([key]) => key);\n\n    this._flagConfiguration = { ...flagConfiguration };\n    this.events.emit(ProviderEvents.ConfigurationChanged, { flagsChanged });\n  }\n\n  resolveBooleanEvaluation(\n    flagKey: string,\n    defaultValue: boolean,\n    context?: EvaluationContext,\n    logger?: Logger,\n  ): Promise<ResolutionDetails<boolean>> {\n    return this.resolveFlagWithReason<boolean>(flagKey, defaultValue, context, logger);\n  }\n\n  resolveNumberEvaluation(\n    flagKey: string,\n    defaultValue: number,\n    context?: EvaluationContext,\n    logger?: Logger,\n  ): Promise<ResolutionDetails<number>> {\n    return this.resolveFlagWithReason<number>(flagKey, defaultValue, context, logger);\n  }\n\n  async resolveStringEvaluation(\n    flagKey: string,\n    defaultValue: string,\n    context?: EvaluationContext,\n    logger?: Logger,\n  ): Promise<ResolutionDetails<string>> {\n    return this.resolveFlagWithReason<string>(flagKey, defaultValue, context, logger);\n  }\n\n  async resolveObjectEvaluation<T extends JsonValue>(\n    flagKey: string,\n    defaultValue: T,\n    context?: EvaluationContext,\n    logger?: Logger,\n  ): Promise<ResolutionDetails<T>> {\n    return this.resolveFlagWithReason<T>(flagKey, defaultValue, context, logger);\n  }\n\n  private async resolveFlagWithReason<T extends JsonValue | FlagValueType>(\n    flagKey: string,\n    defaultValue: T,\n    ctx?: EvaluationContext,\n    logger?: Logger,\n  ): Promise<ResolutionDetails<T>> {\n    try {\n      const resolutionResult = this.lookupFlagValue(flagKey, defaultValue, ctx, logger);\n\n      if (typeof resolutionResult?.value != typeof defaultValue) {\n        throw new TypeMismatchError();\n      }\n\n      return resolutionResult;\n    } catch (error: unknown) {\n      if (!(error instanceof OpenFeatureError)) {\n        throw new GeneralError((error as Error)?.message || 'unknown error'); \n      }\n      throw error;\n    }\n  }\n\n  private lookupFlagValue<T extends JsonValue | FlagValueType>(\n    flagKey: string,\n    defaultValue: T,\n    ctx?: EvaluationContext,\n    logger?: Logger,\n  ): ResolutionDetails<T> {\n    if (!(flagKey in this._flagConfiguration)) {\n      const message = `no flag found with key ${flagKey}`;\n      logger?.debug(message);\n      throw new FlagNotFoundError(message);\n    }\n    const flagSpec: Flag = this._flagConfiguration[flagKey];\n\n    if (flagSpec.disabled) {\n      return { value: defaultValue, reason: StandardResolutionReasons.DISABLED };\n    }\n\n    const isContextEval = ctx && flagSpec?.contextEvaluator;\n    const variant = isContextEval ? flagSpec.contextEvaluator?.(ctx) : flagSpec.defaultVariant;\n\n    const value = variant && flagSpec?.variants[variant];\n\n    if (value === undefined) {\n      const message = `no value associated with variant ${variant}`;\n      logger?.error(message);\n      throw new VariantFoundError(message);\n    }\n\n    return {\n      value: value as T,\n      ...(variant && { variant }),\n      reason: isContextEval ? StandardResolutionReasons.TARGETING_MATCH : StandardResolutionReasons.STATIC,\n    };\n  }\n}\n", "import { ErrorCode, OpenFeatureError } from '@openfeature/core';\n\n/**\n * A custom error for the in-memory provider.\n * Indicates the resolved or default variant doesn't exist.\n */\nexport class VariantFoundError extends OpenFeatureError {\n  code: ErrorCode;\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, VariantFoundError.prototype);\n    this.name = 'VariantFoundError';\n    this.code = ErrorCode.GENERAL;\n  }\n}\n", "import {\n  EvaluationContext,\n  ManageContext,\n  OpenFeatureCommonAPI,\n  ProviderWrapper,\n  ServerProviderStatus,\n  objectOrUndefined,\n  stringOrUndefined,\n} from '@openfeature/core';\nimport { Client } from './client';\nimport { OpenFeatureClient } from './client/internal/open-feature-client';\nimport { OpenFeatureEventEmitter } from './events';\nimport { Hook } from './hooks';\nimport { NOOP_PROVIDER, Provider, ProviderStatus } from './provider';\nimport {\n  ManageTransactionContextPropagator,\n  NOOP_TRANSACTION_CONTEXT_PROPAGATOR,\n  TransactionContext,\n  TransactionContextPropagator,\n} from './transaction-context';\n\n// use a symbol as a key for the global singleton\nconst GLOBAL_OPENFEATURE_API_KEY = Symbol.for('@openfeature/js-sdk/api');\n\ntype OpenFeatureGlobal = {\n  [GLOBAL_OPENFEATURE_API_KEY]?: OpenFeatureAPI;\n};\nconst _globalThis = globalThis as OpenFeatureGlobal;\n\nexport class OpenFeatureAPI\n  extends OpenFeatureCommonAPI<ServerProviderStatus, Provider, Hook>\n  implements\n    ManageContext<OpenFeatureAPI>,\n    ManageTransactionContextPropagator<OpenFeatureCommonAPI<ServerProviderStatus, Provider>>\n{\n  protected _statusEnumType: typeof ProviderStatus = ProviderStatus;\n  protected _apiEmitter = new OpenFeatureEventEmitter();\n  protected _defaultProvider: ProviderWrapper<Provider, ServerProviderStatus> = new ProviderWrapper(\n    NOOP_PROVIDER,\n    ProviderStatus.NOT_READY,\n    this._statusEnumType,\n  );\n  protected _domainScopedProviders: Map<string, ProviderWrapper<Provider, ServerProviderStatus>> = new Map();\n  protected _createEventEmitter = () => new OpenFeatureEventEmitter();\n\n  private _transactionContextPropagator: TransactionContextPropagator = NOOP_TRANSACTION_CONTEXT_PROPAGATOR;\n\n  private constructor() {\n    super('server');\n  }\n\n  /**\n   * Gets a singleton instance of the OpenFeature API.\n   * @ignore\n   * @returns {OpenFeatureAPI} OpenFeature API\n   */\n  static getInstance(): OpenFeatureAPI {\n    const globalApi = _globalThis[GLOBAL_OPENFEATURE_API_KEY];\n    if (globalApi) {\n      return globalApi;\n    }\n\n    const instance = new OpenFeatureAPI();\n    _globalThis[GLOBAL_OPENFEATURE_API_KEY] = instance;\n    return instance;\n  }\n\n  private getProviderStatus(domain?: string): ProviderStatus {\n    if (!domain) {\n      return this._defaultProvider.status;\n    }\n\n    return this._domainScopedProviders.get(domain)?.status ?? this._defaultProvider.status;\n  }\n\n  /**\n   * Sets the default provider for flag evaluations and returns a promise that resolves when the provider is ready.\n   * This provider will be used by domainless clients and clients associated with domains to which no provider is bound.\n   * Setting a provider supersedes the current provider used in new and existing unbound clients.\n   * @param {Provider} provider The provider responsible for flag evaluations.\n   * @returns {Promise<void>}\n   * @throws Uncaught exceptions thrown by the provider during initialization.\n   */\n  setProviderAndWait(provider: Provider): Promise<void>;\n  /**\n   * Sets the provider that OpenFeature will use for flag evaluations on clients bound to the same domain.\n   * A promise is returned that resolves when the provider is ready.\n   * Setting a provider supersedes the current provider used in new and existing clients bound to the same domain.\n   * @param {string} domain The name to identify the client\n   * @param {Provider} provider The provider responsible for flag evaluations.\n   * @returns {Promise<void>}\n   * @throws Uncaught exceptions thrown by the provider during initialization.\n   */\n  setProviderAndWait(domain: string, provider: Provider): Promise<void>;\n  async setProviderAndWait(domainOrProvider?: string | Provider, providerOrUndefined?: Provider): Promise<void> {\n    const domain = stringOrUndefined(domainOrProvider);\n    const provider = domain\n      ? objectOrUndefined<Provider>(providerOrUndefined)\n      : objectOrUndefined<Provider>(domainOrProvider);\n\n    await this.setAwaitableProvider(domain, provider);\n  }\n\n  /**\n   * Sets the default provider for flag evaluations.\n   * This provider will be used by domainless clients and clients associated with domains to which no provider is bound.\n   * Setting a provider supersedes the current provider used in new and existing unbound clients.\n   * @param {Provider} provider The provider responsible for flag evaluations.\n   * @returns {this} OpenFeature API\n   */\n  setProvider(provider: Provider): this;\n  /**\n   * Sets the provider for flag evaluations of providers with the given name.\n   * Setting a provider supersedes the current provider used in new and existing clients bound to the same domain.\n   * @param {string} domain The name to identify the client\n   * @param {Provider} provider The provider responsible for flag evaluations.\n   * @returns {this} OpenFeature API\n   */\n  setProvider(domain: string, provider: Provider): this;\n  setProvider(clientOrProvider?: string | Provider, providerOrUndefined?: Provider): this {\n    const domain = stringOrUndefined(clientOrProvider);\n    const provider = domain\n      ? objectOrUndefined<Provider>(providerOrUndefined)\n      : objectOrUndefined<Provider>(clientOrProvider);\n\n    const maybePromise = this.setAwaitableProvider(domain, provider);\n\n    // The setProvider method doesn't return a promise so we need to catch and\n    // log any errors that occur during provider initialization to avoid having\n    // an unhandled promise rejection.\n    Promise.resolve(maybePromise).catch((err) => {\n      this._logger.error('Error during provider initialization:', err);\n    });\n\n    return this;\n  }\n\n  setContext(context: EvaluationContext): this {\n    this._context = context;\n    return this;\n  }\n\n  getContext(): EvaluationContext {\n    return this._context;\n  }\n\n  /**\n   * A factory function for creating new domainless OpenFeature clients.\n   * Clients can contain their own state (e.g. logger, hook, context).\n   * Multiple clients can be used to segment feature flag configuration.\n   *\n   * All domainless or unbound clients use the default provider set via {@link this.setProvider setProvider}.\n   * @param {EvaluationContext} context Evaluation context that should be set on the client to used during flag evaluations\n   * @returns {Client} OpenFeature Client\n   */\n  getClient(context?: EvaluationContext): Client;\n  /**\n   * A factory function for creating new domain scoped OpenFeature clients.\n   * Clients can contain their own state (e.g. logger, hook, context).\n   * Multiple clients can be used to segment feature flag configuration.\n   *\n   * If there is already a provider bound to this domain via {@link this.setProvider setProvider}, this provider will be used.\n   * Otherwise, the default provider is used until a provider is assigned to that domain.\n   * @param {string} domain An identifier which logically binds clients with providers\n   * @param {EvaluationContext} context Evaluation context that should be set on the client to used during flag evaluations\n   * @returns {Client} OpenFeature Client\n   */\n  getClient(domain: string, context?: EvaluationContext): Client;\n  /**\n   * A factory function for creating new domain scoped OpenFeature clients.\n   * Clients can contain their own state (e.g. logger, hook, context).\n   * Multiple clients can be used to segment feature flag configuration.\n   *\n   * If there is already a provider bound to this domain via {@link this.setProvider setProvider}, this provider will be used.\n   * Otherwise, the default provider is used until a provider is assigned to that domain.\n   * @param {string} domain An identifier which logically binds clients with providers\n   * @param {string} version The version of the client (only used for metadata)\n   * @param {EvaluationContext} context Evaluation context that should be set on the client to used during flag evaluations\n   * @returns {Client} OpenFeature Client\n   */\n  getClient(domain: string, version: string, context?: EvaluationContext): Client;\n  getClient(\n    domainOrContext?: string | EvaluationContext,\n    versionOrContext?: string | EvaluationContext,\n    contextOrUndefined?: EvaluationContext,\n  ): Client {\n    const domain = stringOrUndefined(domainOrContext);\n    const version = stringOrUndefined(versionOrContext);\n    const context =\n      objectOrUndefined<EvaluationContext>(domainOrContext) ??\n      objectOrUndefined<EvaluationContext>(versionOrContext) ??\n      objectOrUndefined<EvaluationContext>(contextOrUndefined);\n\n    return new OpenFeatureClient(\n      () => this.getProviderForClient(domain),\n      () => this.getProviderStatus(domain),\n      () => this.buildAndCacheEventEmitterForClient(domain),\n      () => this._logger,\n      { domain, version },\n      context,\n    );\n  }\n\n  /**\n   * Clears all registered providers and resets the default provider.\n   * @returns {Promise<void>}\n   */\n  clearProviders(): Promise<void> {\n    return super.clearProvidersAndSetDefault(NOOP_PROVIDER);\n  }\n\n  setTransactionContextPropagator(\n    transactionContextPropagator: TransactionContextPropagator,\n  ): OpenFeatureCommonAPI<ServerProviderStatus, Provider> {\n    const baseMessage = 'Invalid TransactionContextPropagator, will not be set: ';\n    if (typeof transactionContextPropagator?.getTransactionContext !== 'function') {\n      this._logger.error(`${baseMessage}: getTransactionContext is not a function.`);\n    } else if (typeof transactionContextPropagator?.setTransactionContext !== 'function') {\n      this._logger.error(`${baseMessage}: setTransactionContext is not a function.`);\n    } else {\n      this._transactionContextPropagator = transactionContextPropagator;\n    }\n    return this;\n  }\n\n  setTransactionContext<TArgs extends unknown[], R>(\n    transactionContext: TransactionContext,\n    callback: (...args: TArgs) => R,\n    ...args: TArgs\n  ): void {\n    this._transactionContextPropagator.setTransactionContext(transactionContext, callback, ...args);\n  }\n\n  getTransactionContext(): TransactionContext {\n    try {\n      return this._transactionContextPropagator.getTransactionContext();\n    } catch (err: unknown) {\n      const error = err as Error | undefined;\n      this._logger.error(`Error getting transaction context: ${error?.message}, returning empty context.`);\n      this._logger.error(error?.stack);\n      return {};\n    }\n  }\n}\n\n/**\n * A singleton instance of the OpenFeature API.\n * @returns {OpenFeatureAPI} OpenFeature API\n */\nexport const OpenFeature = OpenFeatureAPI.getInstance();\n", "import {\n  ClientMetadata,\n  ErrorCode,\n  EvaluationContext,\n  EvaluationDetails,\n  EventHandler,\n  FlagValue,\n  FlagValueType,\n  HookContext,\n  JsonValue,\n  Logger,\n  OpenFeatureError,\n  ProviderFatalError,\n  ProviderNotReadyError,\n  ResolutionDetails,\n  SafeLogger,\n  StandardResolutionReasons,\n  instantiateErrorByErrorCode,\n  statusMatchesEvent,\n} from '@openfeature/core';\nimport { FlagEvaluationOptions } from '../../evaluation';\nimport { ProviderEvents } from '../../events';\nimport { InternalEventEmitter } from '../../events/internal/internal-event-emitter';\nimport { Hook } from '../../hooks';\nimport { OpenFeature } from '../../open-feature';\nimport { Provider, ProviderStatus } from '../../provider';\nimport { Client } from './../client';\n\ntype OpenFeatureClientOptions = {\n  /**\n   * @deprecated Use `domain` instead.\n   */\n  name?: string;\n  domain?: string;\n  version?: string;\n};\n\n/**\n * This implementation of the {@link Client} is meant to only be instantiated by the SDK.\n * It should not be used outside the SDK and so should not be exported.\n * @internal\n */\nexport class OpenFeatureClient implements Client {\n  private _context: EvaluationContext;\n  private _hooks: Hook[] = [];\n  private _clientLogger?: Logger;\n\n  constructor(\n    // we always want the client to use the current provider,\n    // so pass a function to always access the currently registered one.\n    private readonly providerAccessor: () => Provider,\n    private readonly providerStatusAccessor: () => ProviderStatus,\n    private readonly emitterAccessor: () => InternalEventEmitter,\n    private readonly globalLogger: () => Logger,\n    private readonly options: OpenFeatureClientOptions,\n    context: EvaluationContext = {},\n  ) {\n    this._context = context;\n  }\n\n  get metadata(): ClientMetadata {\n    return {\n      // Use domain if name is not provided\n      name: this.options.domain ?? this.options.name,\n      domain: this.options.domain ?? this.options.name,\n      version: this.options.version,\n      providerMetadata: this.providerAccessor().metadata,\n    };\n  }\n\n  get providerStatus(): ProviderStatus {\n    return this.providerStatusAccessor();\n  }\n\n  addHandler(eventType: ProviderEvents, handler: EventHandler): void {\n    this.emitterAccessor().addHandler(eventType, handler);\n    const shouldRunNow = statusMatchesEvent(eventType, this._providerStatus);\n\n    if (shouldRunNow) {\n      // run immediately, we're in the matching state\n      try {\n        handler({\n          clientName: this.metadata.name,\n          domain: this.metadata.domain,\n          providerName: this._provider.metadata.name,\n        });\n      } catch (err) {\n        this._logger?.error('Error running event handler:', err);\n      }\n    }\n  }\n\n  removeHandler(eventType: ProviderEvents, handler: EventHandler) {\n    this.emitterAccessor().removeHandler(eventType, handler);\n  }\n\n  getHandlers(eventType: ProviderEvents) {\n    return this.emitterAccessor().getHandlers(eventType);\n  }\n\n  setLogger(logger: Logger): OpenFeatureClient {\n    this._clientLogger = new SafeLogger(logger);\n    return this;\n  }\n\n  setContext(context: EvaluationContext): OpenFeatureClient {\n    this._context = context;\n    return this;\n  }\n\n  getContext(): EvaluationContext {\n    return this._context;\n  }\n\n  addHooks(...hooks: Hook[]): OpenFeatureClient {\n    this._hooks = [...this._hooks, ...hooks];\n    return this;\n  }\n\n  getHooks(): Hook[] {\n    return this._hooks;\n  }\n\n  clearHooks(): OpenFeatureClient {\n    this._hooks = [];\n    return this;\n  }\n\n  async getBooleanValue(\n    flagKey: string,\n    defaultValue: boolean,\n    context?: EvaluationContext,\n    options?: FlagEvaluationOptions,\n  ): Promise<boolean> {\n    return (await this.getBooleanDetails(flagKey, defaultValue, context, options)).value;\n  }\n\n  getBooleanDetails(\n    flagKey: string,\n    defaultValue: boolean,\n    context?: EvaluationContext,\n    options?: FlagEvaluationOptions,\n  ): Promise<EvaluationDetails<boolean>> {\n    return this.evaluate<boolean>(\n      flagKey,\n      this._provider.resolveBooleanEvaluation,\n      defaultValue,\n      'boolean',\n      context,\n      options,\n    );\n  }\n\n  async getStringValue<T extends string = string>(\n    flagKey: string,\n    defaultValue: T,\n    context?: EvaluationContext,\n    options?: FlagEvaluationOptions,\n  ): Promise<T> {\n    return (await this.getStringDetails<T>(flagKey, defaultValue, context, options)).value;\n  }\n\n  getStringDetails<T extends string = string>(\n    flagKey: string,\n    defaultValue: T,\n    context?: EvaluationContext,\n    options?: FlagEvaluationOptions,\n  ): Promise<EvaluationDetails<T>> {\n    return this.evaluate<T>(\n      flagKey,\n      // this isolates providers from our restricted string generic argument.\n      this._provider.resolveStringEvaluation as () => Promise<EvaluationDetails<T>>,\n      defaultValue,\n      'string',\n      context,\n      options,\n    );\n  }\n\n  async getNumberValue<T extends number = number>(\n    flagKey: string,\n    defaultValue: T,\n    context?: EvaluationContext,\n    options?: FlagEvaluationOptions,\n  ): Promise<T> {\n    return (await this.getNumberDetails(flagKey, defaultValue, context, options)).value;\n  }\n\n  getNumberDetails<T extends number = number>(\n    flagKey: string,\n    defaultValue: T,\n    context?: EvaluationContext,\n    options?: FlagEvaluationOptions,\n  ): Promise<EvaluationDetails<T>> {\n    return this.evaluate<T>(\n      flagKey,\n      // this isolates providers from our restricted number generic argument.\n      this._provider.resolveNumberEvaluation as () => Promise<EvaluationDetails<T>>,\n      defaultValue,\n      'number',\n      context,\n      options,\n    );\n  }\n\n  async getObjectValue<T extends JsonValue = JsonValue>(\n    flagKey: string,\n    defaultValue: T,\n    context?: EvaluationContext,\n    options?: FlagEvaluationOptions,\n  ): Promise<T> {\n    return (await this.getObjectDetails(flagKey, defaultValue, context, options)).value;\n  }\n\n  getObjectDetails<T extends JsonValue = JsonValue>(\n    flagKey: string,\n    defaultValue: T,\n    context?: EvaluationContext,\n    options?: FlagEvaluationOptions,\n  ): Promise<EvaluationDetails<T>> {\n    return this.evaluate<T>(flagKey, this._provider.resolveObjectEvaluation, defaultValue, 'object', context, options);\n  }\n\n  private async evaluate<T extends FlagValue>(\n    flagKey: string,\n    resolver: (\n      flagKey: string,\n      defaultValue: T,\n      context: EvaluationContext,\n      logger: Logger,\n    ) => Promise<ResolutionDetails<T>>,\n    defaultValue: T,\n    flagType: FlagValueType,\n    invocationContext: EvaluationContext = {},\n    options: FlagEvaluationOptions = {},\n  ): Promise<EvaluationDetails<T>> {\n    // merge global, client, and evaluation context\n\n    const allHooks = [\n      ...OpenFeature.getHooks(),\n      ...this.getHooks(),\n      ...(options.hooks || []),\n      ...(this._provider.hooks || []),\n    ];\n    const allHooksReversed = [...allHooks].reverse();\n\n    // merge global and client contexts\n    const mergedContext = {\n      ...OpenFeature.getContext(),\n      ...OpenFeature.getTransactionContext(),\n      ...this._context,\n      ...invocationContext,\n    };\n\n    // this reference cannot change during the course of evaluation\n    // it may be used as a key in WeakMaps\n    const hookContext: Readonly<HookContext> = {\n      flagKey,\n      defaultValue,\n      flagValueType: flagType,\n      clientMetadata: this.metadata,\n      providerMetadata: this._provider.metadata,\n      context: mergedContext,\n      logger: this._logger,\n    };\n\n    try {\n      const frozenContext = await this.beforeHooks(allHooks, hookContext, options);\n\n      // short circuit evaluation entirely if provider is in a bad state\n      if (this.providerStatus === ProviderStatus.NOT_READY) {\n        throw new ProviderNotReadyError('provider has not yet initialized');\n      } else if (this.providerStatus === ProviderStatus.FATAL) {\n        throw new ProviderFatalError('provider is in an irrecoverable error state');\n      }\n\n      // run the referenced resolver, binding the provider.\n      const resolution = await resolver.call(this._provider, flagKey, defaultValue, frozenContext, this._logger);\n\n      const evaluationDetails = {\n        ...resolution,\n        flagMetadata: Object.freeze(resolution.flagMetadata ?? {}),\n        flagKey,\n      };\n\n      if (evaluationDetails.errorCode) {\n        throw instantiateErrorByErrorCode(evaluationDetails.errorCode);\n      }\n\n      await this.afterHooks(allHooksReversed, hookContext, evaluationDetails, options);\n\n      return evaluationDetails;\n    } catch (err: unknown) {\n      const errorMessage: string = (err as Error)?.message;\n      const errorCode: ErrorCode = (err as OpenFeatureError)?.code || ErrorCode.GENERAL;\n\n      await this.errorHooks(allHooksReversed, hookContext, err, options);\n\n      return {\n        errorCode,\n        errorMessage,\n        value: defaultValue,\n        reason: StandardResolutionReasons.ERROR,\n        flagMetadata: Object.freeze({}),\n        flagKey,\n      };\n    } finally {\n      await this.finallyHooks(allHooksReversed, hookContext, options);\n    }\n  }\n\n  private async beforeHooks(hooks: Hook[], hookContext: HookContext, options: FlagEvaluationOptions) {\n    for (const hook of hooks) {\n      // freeze the hookContext\n      Object.freeze(hookContext);\n\n      // use Object.assign to avoid modification of frozen hookContext\n      Object.assign(hookContext.context, {\n        ...hookContext.context,\n        ...(await hook?.before?.(hookContext, Object.freeze(options.hookHints))),\n      });\n    }\n\n    // after before hooks, freeze the EvaluationContext.\n    return Object.freeze(hookContext.context);\n  }\n\n  private async afterHooks(\n    hooks: Hook[],\n    hookContext: HookContext,\n    evaluationDetails: EvaluationDetails<FlagValue>,\n    options: FlagEvaluationOptions,\n  ) {\n    // run \"after\" hooks sequentially\n    for (const hook of hooks) {\n      await hook?.after?.(hookContext, evaluationDetails, options.hookHints);\n    }\n  }\n\n  private async errorHooks(hooks: Hook[], hookContext: HookContext, err: unknown, options: FlagEvaluationOptions) {\n    // run \"error\" hooks sequentially\n    for (const hook of hooks) {\n      try {\n        await hook?.error?.(hookContext, err, options.hookHints);\n      } catch (err) {\n        this._logger.error(`Unhandled error during 'error' hook: ${err}`);\n        if (err instanceof Error) {\n          this._logger.error(err.stack);\n        }\n        this._logger.error((err as Error)?.stack);\n      }\n    }\n  }\n\n  private async finallyHooks(hooks: Hook[], hookContext: HookContext, options: FlagEvaluationOptions) {\n    // run \"finally\" hooks sequentially\n    for (const hook of hooks) {\n      try {\n        await hook?.finally?.(hookContext, options.hookHints);\n      } catch (err) {\n        this._logger.error(`Unhandled error during 'finally' hook: ${err}`);\n        if (err instanceof Error) {\n          this._logger.error(err.stack);\n        }\n        this._logger.error((err as Error)?.stack);\n      }\n    }\n  }\n\n  private get _provider(): Provider {\n    return this.providerAccessor();\n  }\n\n  private get _providerStatus(): ProviderStatus {\n    return this.providerStatusAccessor();\n  }\n\n  private get _logger() {\n    return this._clientLogger || this.globalLogger();\n  }\n}\n", "import { GenericEventEmitter } from '@openfeature/core';\nimport { EventEmitter } from 'node:events';\nimport { ProviderEvents } from './events';\n\n/**\n * The OpenFeatureEventEmitter can be used by provider developers to emit\n * events at various parts of the provider lifecycle.\n * \n * NOTE: Ready and error events are automatically emitted by the SDK based on\n * the result of the initialize method.\n */\nexport class OpenFeatureEventEmitter extends GenericEventEmitter<ProviderEvents> {\n  protected readonly eventEmitter = new EventEmitter({ captureRejections: true });\n\n   constructor() {\n      super();\n      this.eventEmitter.on('error', (err) => {\n        this._logger?.error('Error running event handler:', err);\n      });\n    }\n};", "import { ServerProviderEvents } from '@openfeature/core';\n\nexport { ServerProviderEvents as ProviderEvents };", "import { EvaluationContext } from '@openfeature/core';\nimport { TransactionContext, TransactionContextPropagator } from './transaction-context';\n\nclass NoopTransactionContextPropagator implements TransactionContextPropagator {\n  getTransactionContext(): EvaluationContext {\n    return {};\n  }\n\n  setTransactionContext<TArgs extends unknown[], R>(\n    _: TransactionContext,\n    callback: (...args: TArgs) => R,\n    ...args: TArgs\n  ): void {\n    callback(...args);\n  }\n}\n\nexport const NOOP_TRANSACTION_CONTEXT_PROPAGATOR = new NoopTransactionContextPropagator();\n", "import { EvaluationContext } from '@openfeature/core';\nimport { TransactionContext, TransactionContextPropagator } from './transaction-context';\nimport { AsyncLocalStorage } from 'async_hooks';\n\nexport class AsyncLocalStorageTransactionContextPropagator implements TransactionContextPropagator {\n  private asyncLocalStorage = new AsyncLocalStorage<EvaluationContext>();\n\n  getTransactionContext(): EvaluationContext {\n    return this.asyncLocalStorage.getStore() ?? {};\n  }\n\n  setTransactionContext<TArgs extends unknown[], R>(\n    transactionContext: TransactionContext,\n    callback: (...args: TArgs) => R,\n    ...args: TArgs\n  ): void {\n    this.asyncLocalStorage.run(transactionContext, callback, ...args);\n  }\n}\n", "export * from './client';\nexport * from './provider';\nexport * from './evaluation';\nexport * from './open-feature';\nexport * from './transaction-context';\nexport * from './events';\nexport * from './hooks';\nexport * from '@openfeature/core';\n"],
  "mappings": "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",
  "names": ["OpenFeatureError", "OpenFeatureError", "ErrorCode", "StandardResolutionReasons", "ErrorCode", "StandardResolutionReasons", "err"]
}
