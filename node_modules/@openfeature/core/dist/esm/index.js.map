{
  "version": 3,
  "sources": ["../../src/evaluation/evaluation.ts", "../../src/errors/open-feature-error-abstract.ts", "../../src/errors/flag-not-found-error.ts", "../../src/errors/general-error.ts", "../../src/errors/invalid-context-error.ts", "../../src/errors/parse-error.ts", "../../src/errors/provider-fatal-error.ts", "../../src/errors/provider-not-ready-error.ts", "../../src/errors/targeting-key-missing-error.ts", "../../src/errors/type-mismatch-error.ts", "../../src/errors/index.ts", "../../src/provider/provider.ts", "../../src/events/events.ts", "../../src/events/event-utils.ts", "../../src/logger/default-logger.ts", "../../src/logger/safe-logger.ts", "../../src/events/generic-event-emitter.ts", "../../src/type-guards.ts", "../../src/filter.ts", "../../src/open-feature.ts"],
  "sourcesContent": ["export type FlagValueType = 'boolean' | 'string' | 'number' | 'object';\n\nexport type PrimitiveValue = null | boolean | string | number;\nexport type JsonObject = { [key: string]: JsonValue };\nexport type JsonArray = JsonValue[];\n\n/**\n * Represents a JSON node value.\n */\nexport type JsonValue = PrimitiveValue | JsonObject | JsonArray;\n\n/**\n * Represents a JSON node value, or Date.\n */\nexport type FlagValue = boolean | string | number | JsonValue;\n\nexport type ResolutionReason = keyof typeof StandardResolutionReasons | (string & Record<never, never>);\n\n/**\n * A structure which supports definition of arbitrary properties, with keys of type string, and values of type boolean, string, or number.\n *\n * This structure is populated by a provider for use by an Application Author (via the Evaluation API) or an Application Integrator (via hooks).\n */\nexport type FlagMetadata = Record<string, string | number | boolean>;\n\nexport type ResolutionDetails<U> = {\n  value: U;\n  variant?: string;\n  flagMetadata?: FlagMetadata;\n  reason?: ResolutionReason;\n  errorCode?: ErrorCode;\n  errorMessage?: string;\n};\n\nexport type EvaluationDetails<T extends FlagValue> = {\n  flagKey: string;\n  flagMetadata: Readonly<FlagMetadata>;\n} & ResolutionDetails<T>;\n\nexport const StandardResolutionReasons = {\n  /**\n   * The resolved value is static (no dynamic evaluation).\n   */\n  STATIC: 'STATIC',\n\n  /**\n   *  The resolved value was configured statically, or otherwise fell back to a pre-configured value.\n   */\n  DEFAULT: 'DEFAULT',\n\n  /**\n   * The resolved value was the result of a dynamic evaluation, such as a rule or specific user-targeting.\n   */\n  TARGETING_MATCH: 'TARGETING_MATCH',\n\n  /**\n   * The resolved value was the result of pseudorandom assignment.\n   */\n  SPLIT: 'SPLIT',\n\n  /**\n   * The resolved value was retrieved from cache.\n   */\n  CACHED: 'CACHED',\n\n  /**\n   * The resolved value was the result of the flag being disabled in the management system.\n   */\n  DISABLED: 'DISABLED',\n\n  /**\n   * The reason for the resolved value could not be determined.\n   */\n  UNKNOWN: 'UNKNOWN',\n\n  /**\n   * The resolved value is non-authoritative or possibly out of date.\n   */\n  STALE: 'STALE',\n\n  /**\n   * The resolved value was the result of an error.\n   *\n   * Note: The `errorCode` and `errorMessage` fields may contain additional details of this error.\n   */\n  ERROR: 'ERROR',\n} as const;\n\nexport enum ErrorCode {\n  /**\n   * The value was resolved before the provider was ready.\n   */\n  PROVIDER_NOT_READY = 'PROVIDER_NOT_READY',\n\n  /**\n   * The provider has entered an irrecoverable error state.\n   */\n  PROVIDER_FATAL = 'PROVIDER_FATAL',\n\n  /**\n   * The flag could not be found.\n   */\n  FLAG_NOT_FOUND = 'FLAG_NOT_FOUND',\n\n  /**\n   * An error was encountered parsing data, such as a flag configuration.\n   */\n  PARSE_ERROR = 'PARSE_ERROR',\n\n  /**\n   * The type of the flag value does not match the expected type.\n   */\n  TYPE_MISMATCH = 'TYPE_MISMATCH',\n\n  /**\n   * The provider requires a targeting key and one was not provided in the evaluation context.\n   */\n  TARGETING_KEY_MISSING = 'TARGETING_KEY_MISSING',\n\n  /**\n   * The evaluation context does not meet provider requirements.\n   */\n  INVALID_CONTEXT = 'INVALID_CONTEXT',\n\n  /**\n   * An error with an unspecified code.\n   */\n  GENERAL = 'GENERAL',\n}\n", "import { ErrorCode } from '../evaluation';\n\n/**\n * Error Options were added in ES2022. Manually adding the type so that an\n * earlier target can be used.\n */\nexport type ErrorOptions = {\n  cause?: unknown\n};\n\nexport abstract class OpenFeatureError extends Error {\n  abstract code: ErrorCode;\n  cause?: unknown;\n  constructor(message?: string, options?: ErrorOptions) {\n    super(message);\n    Object.setPrototypeOf(this, OpenFeatureError.prototype);\n    this.name = 'OpenFeatureError';\n    this.cause = options?.cause;\n  }\n}\n", "import { ErrorOptions, OpenFeatureError } from './open-feature-error-abstract';\nimport { ErrorCode } from '../evaluation';\n\nexport class FlagNotFoundError extends OpenFeatureError {\n  code: ErrorCode;\n  constructor(message?: string, options?: ErrorOptions) {\n    super(message, options);\n    Object.setPrototypeOf(this, FlagNotFoundError.prototype);\n    this.name = 'FlagNotFoundError';\n    this.code = ErrorCode.FLAG_NOT_FOUND;\n  }\n}\n", "import { ErrorOptions, OpenFeatureError } from './open-feature-error-abstract';\nimport { ErrorCode } from '../evaluation';\n\nexport class GeneralError extends OpenFeatureError {\n  code: ErrorCode;\n  constructor(message?: string, options?: ErrorOptions) {\n    super(message, options);\n    Object.setPrototypeOf(this, GeneralError.prototype);\n    this.name = 'GeneralError';\n    this.code = ErrorCode.GENERAL;\n  }\n}\n", "import { ErrorOptions, OpenFeatureError } from './open-feature-error-abstract';\nimport { ErrorCode } from '../evaluation';\n\nexport class InvalidContextError extends OpenFeatureError {\n  code: ErrorCode;\n  constructor(message?: string, options?: ErrorOptions) {\n    super(message, options);\n    Object.setPrototypeOf(this, InvalidContextError.prototype);\n    this.name = 'InvalidContextError';\n    this.code = ErrorCode.INVALID_CONTEXT;\n  }\n}\n", "import { ErrorOptions, OpenFeatureError } from './open-feature-error-abstract';\nimport { ErrorCode } from '../evaluation';\n\nexport class ParseError extends OpenFeatureError {\n  code: ErrorCode;\n  constructor(message?: string, options?: ErrorOptions) {\n    super(message, options);\n    Object.setPrototypeOf(this, ParseError.prototype);\n    this.name = 'ParseError';\n    this.code = ErrorCode.PARSE_ERROR;\n  }\n}\n", "import { ErrorOptions, OpenFeatureError } from './open-feature-error-abstract';\nimport { ErrorCode } from '../evaluation';\n\nexport class ProviderFatalError extends OpenFeatureError {\n  code: ErrorCode;\n  constructor(message?: string, options?: ErrorOptions) {\n    super(message, options);\n    Object.setPrototypeOf(this, ProviderFatalError.prototype);\n    this.name = 'ProviderFatalError';\n    this.code = ErrorCode.PROVIDER_FATAL;\n  }\n}\n", "import { ErrorOptions, OpenFeatureError } from './open-feature-error-abstract';\nimport { ErrorCode } from '../evaluation';\n\nexport class ProviderNotReadyError extends OpenFeatureError {\n  code: ErrorCode;\n  constructor(message?: string, options?: ErrorOptions) {\n    super(message, options);\n    Object.setPrototypeOf(this, ProviderNotReadyError.prototype);\n    this.name = 'ProviderNotReadyError';\n    this.code = ErrorCode.PROVIDER_NOT_READY;\n  }\n}\n", "import { ErrorOptions, OpenFeatureError } from './open-feature-error-abstract';\nimport { ErrorCode } from '../evaluation';\n\nexport class TargetingKeyMissingError extends OpenFeatureError {\n  code: ErrorCode;\n  constructor(message?: string, options?: ErrorOptions) {\n    super(message, options);\n    Object.setPrototypeOf(this, TargetingKeyMissingError.prototype);\n    this.name = 'TargetingKeyMissingError';\n    this.code = ErrorCode.TARGETING_KEY_MISSING;\n  }\n}\n", "import { ErrorOptions, OpenFeatureError } from './open-feature-error-abstract';\nimport { ErrorCode } from '../evaluation';\n\nexport class TypeMismatchError extends OpenFeatureError {\n  code: ErrorCode;\n  constructor(message?: string, options?: ErrorOptions) {\n    super(message, options);\n    Object.setPrototypeOf(this, TypeMismatchError.prototype);\n    this.name = 'TypeMismatchError';\n    this.code = ErrorCode.TYPE_MISMATCH;\n  }\n}\n", "import { ErrorCode } from '../evaluation';\n\nimport { FlagNotFoundError } from './flag-not-found-error';\nimport { GeneralError } from './general-error';\nimport { InvalidContextError } from './invalid-context-error';\nimport { OpenFeatureError } from './open-feature-error-abstract';\nimport { ParseError } from './parse-error';\nimport { ProviderFatalError } from './provider-fatal-error';\nimport { ProviderNotReadyError } from './provider-not-ready-error';\nimport { TargetingKeyMissingError } from './targeting-key-missing-error';\nimport { TypeMismatchError } from './type-mismatch-error';\n\nconst instantiateErrorByErrorCode = (errorCode: ErrorCode, message?: string): OpenFeatureError => {\n  switch (errorCode) {\n    case ErrorCode.FLAG_NOT_FOUND:\n      return new FlagNotFoundError(message);\n    case ErrorCode.PARSE_ERROR:\n      return new ParseError(message);\n    case ErrorCode.TYPE_MISMATCH:\n      return new TypeMismatchError(message);\n    case ErrorCode.TARGETING_KEY_MISSING:\n      return new TargetingKeyMissingError(message);\n    case ErrorCode.INVALID_CONTEXT:\n      return new InvalidContextError(message);\n    case ErrorCode.PROVIDER_NOT_READY:\n      return new ProviderNotReadyError(message);\n    case ErrorCode.PROVIDER_FATAL:\n      return new ProviderFatalError(message);\n    default:\n      return new GeneralError(message);\n  }\n};\n\nexport {\n  FlagNotFoundError,\n  GeneralError,\n  InvalidContextError,\n  ParseError,\n  ProviderFatalError,\n  ProviderNotReadyError,\n  TargetingKeyMissingError,\n  TypeMismatchError,\n  OpenFeatureError,\n  instantiateErrorByErrorCode,\n};\n", "import { EvaluationContext } from '../evaluation';\nimport { AnyProviderEvent, ProviderEventEmitter } from '../events';\nimport { Metadata, Paradigm } from '../types';\n\n// TODO: with TypeScript 5+, we can use computed string properties,\n// so we can extract all of these into a shared set of string consts and use that in both enums\n// for now we have duplicated them.\n\n/**\n * The state of the provider.\n * Note that the provider's state is handled by the SDK.\n */\nexport enum ServerProviderStatus {\n  /**\n   * The provider has not been initialized and cannot yet evaluate flags.\n   */\n  NOT_READY = 'NOT_READY',\n\n  /**\n   * The provider is ready to resolve flags.\n   */\n  READY = 'READY',\n\n  /**\n   * The provider is in an error state and unable to evaluate flags.\n   */\n  ERROR = 'ERROR',\n\n  /**\n   * The provider's cached state is no longer valid and may not be up-to-date with the source of truth.\n   */\n  STALE = 'STALE',\n\n  /**\n   * The provider has entered an irrecoverable error state.\n   */\n  FATAL = 'FATAL',\n}\n\n/**\n * The state of the provider.\n * Note that the provider's state is handled by the SDK.\n */\nexport enum ClientProviderStatus {\n  /**\n   * The provider has not been initialized and cannot yet evaluate flags.\n   */\n  NOT_READY = 'NOT_READY',\n\n  /**\n   * The provider is ready to resolve flags.\n   */\n  READY = 'READY',\n\n  /**\n   * The provider is in an error state and unable to evaluate flags.\n   */\n  ERROR = 'ERROR',\n\n  /**\n   * The provider's cached state is no longer valid and may not be up-to-date with the source of truth.\n   */\n  STALE = 'STALE',\n\n  /**\n   * The provider has entered an irrecoverable error state.\n   */\n  FATAL = 'FATAL',\n\n  /**\n   * The provider is reconciling its state with a context change.\n   */\n  RECONCILING = 'RECONCILING',\n}\n\n/**\n * A type representing any possible ProviderStatus (server or client side).\n * In most cases, you probably want to import `ProviderStatus` from the respective SDK.\n */\nexport { ClientProviderStatus as AllProviderStatus };\n\n/**\n * Static data about the provider.\n */\nexport interface ProviderMetadata extends Metadata {\n  readonly name: string;\n}\n\nexport interface CommonProvider<S extends ClientProviderStatus | ServerProviderStatus> {\n  readonly metadata: ProviderMetadata;\n\n  /**\n   * Represents where the provider is intended to be run. If defined,\n   * the SDK will enforce that the defined paradigm at runtime.\n   */\n  readonly runsOn?: Paradigm;\n\n  // TODO: in the future we could make this a never to force provider to remove it.\n  /**\n   * @deprecated the SDK now maintains the provider's state; there's no need for providers to implement this field.\n   * Returns a representation of the current readiness of the provider.\n   * \n   * _Providers which do not implement this method are assumed to be ready immediately._\n   */\n  readonly status?: S;\n\n  /**\n   * An event emitter for ProviderEvents.\n   * @see ProviderEvents\n   */\n  events?: ProviderEventEmitter<AnyProviderEvent>;\n\n  /**\n   * A function used to shut down the provider.\n   * Called when this provider is replaced with a new one, or when the OpenFeature is shut down.\n   */\n  onClose?(): Promise<void>;\n\n  /**\n   * A function used to setup the provider.\n   * Called by the SDK after the provider is set if the provider's status is NOT_READY.\n   * When the returned promise resolves, the SDK fires the ProviderEvents.Ready event.\n   * If the returned promise rejects, the SDK fires the ProviderEvents.Error event.\n   * Use this function to perform any context-dependent setup within the provider.\n   * @param context\n   */\n  initialize?(context?: EvaluationContext): Promise<void>;\n}", "// TODO: with TypeScript 5+, we can use computed string properties,\n// so we can extract all of these into a shared set of string consts and use that in both enums\n// for now we have duplicated them.\n\n/**\n * An enumeration of possible events for server-sdk providers.\n */\nexport enum ServerProviderEvents {\n  /**\n   * The provider is ready to evaluate flags.\n   */\n  Ready = 'PROVIDER_READY',\n\n  /**\n   * The provider is in an error state.\n   */\n  Error = 'PROVIDER_ERROR',\n\n  /**\n   * The flag configuration in the source-of-truth has changed.\n   */\n  ConfigurationChanged = 'PROVIDER_CONFIGURATION_CHANGED',\n\n  /**\n   * The provider's cached state is no longer valid and may not be up-to-date with the source of truth.\n   */\n  Stale = 'PROVIDER_STALE',\n}\n\n/**\n * An enumeration of possible events for web-sdk providers.\n */\nexport enum ClientProviderEvents {\n  /**\n   * The provider is ready to evaluate flags.\n   */\n  Ready = 'PROVIDER_READY',\n\n  /**\n   * The provider is in an error state.\n   */\n  Error = 'PROVIDER_ERROR',\n\n  /**\n   * The flag configuration in the source-of-truth has changed.\n   */\n  ConfigurationChanged = 'PROVIDER_CONFIGURATION_CHANGED',\n\n  /**\n   * The context associated with the provider has changed, and the provider has reconciled it's associated state.\n   */\n  ContextChanged = 'PROVIDER_CONTEXT_CHANGED',\n\n  /**\n   * The context associated with the provider has changed, and the provider has not yet reconciled its associated state.\n   */\n  Reconciling = 'PROVIDER_RECONCILING',\n\n  /**\n   * The provider's cached state is no longer valid and may not be up-to-date with the source of truth.\n   */\n  Stale = 'PROVIDER_STALE',\n}\n\n\n/* alias because in many cases, we iterate over all possible events in code,\nso we have to do this on ClientProviderEvents to be exhaustive */\nexport { ClientProviderEvents as AllProviderEvents };\n\n/**\n * A type representing any possible ProviderEvent (server or client side).\n * In most cases, you probably want to import `ProviderEvents` from the respective SDK.\n */\nexport type AnyProviderEvent = ServerProviderEvents | ClientProviderEvents;\n", "import { AllProviderStatus, ClientProviderStatus, ServerProviderStatus } from '../provider';\nimport { AllProviderEvents, AnyProviderEvent } from './events';\n\nconst eventStatusMap = {\n    [AllProviderStatus.READY]: AllProviderEvents.Ready,\n    [AllProviderStatus.ERROR]: AllProviderEvents.Error,\n    [AllProviderStatus.FATAL]: AllProviderEvents.Error,\n    [AllProviderStatus.STALE]: AllProviderEvents.Stale,\n    [AllProviderStatus.RECONCILING]: AllProviderEvents.Reconciling,\n    [AllProviderStatus.NOT_READY]: undefined,\n};\n\n/**\n * Returns true if the provider's status corresponds to the event.\n * If the provider's status is not defined, it matches READY.\n * @param {AnyProviderEvent} event event to match\n * @param {ClientProviderStatus | ServerProviderStatus} status  status of provider\n * @returns {boolean} boolean indicating if the provider status corresponds to the event.\n */\nexport const statusMatchesEvent = <T extends AnyProviderEvent>(event: T, status?: ClientProviderStatus | ServerProviderStatus): boolean => {\n    return (!status && event === AllProviderEvents.Ready) || eventStatusMap[status!] === event;\n};", "/* eslint-disable @typescript-eslint/no-empty-function */\n\nimport { Logger } from './logger';\n\nexport class DefaultLogger implements Logger {\n  error(...args: unknown[]): void {\n    console.error(...args);\n  }\n\n  warn(...args: unknown[]): void {\n    console.warn(...args);\n  }\n\n  info(): void {}\n\n  debug(): void {}\n}\n", "import { Logger } from './logger';\nimport { DefaultLogger } from './default-logger';\n\nexport const LOG_LEVELS: Array<keyof Logger> = ['error', 'warn', 'info', 'debug'];\n\nexport class SafeLogger implements Logger {\n  private readonly logger: Logger;\n  private readonly fallbackLogger = new DefaultLogger();\n\n  constructor(logger: Logger) {\n    try {\n      for (const level of LOG_LEVELS) {\n        if (!logger[level] || typeof logger[level] !== 'function') {\n          throw new Error(`The provided logger is missing the ${level} method.`);\n        }\n      }\n      this.logger = logger;\n    } catch (err) {\n      console.error(err);\n      console.error('Falling back to the default logger.');\n      this.logger = this.fallbackLogger;\n    }\n  }\n\n  error(...args: unknown[]): void {\n    this.log('error', ...args);\n  }\n\n  warn(...args: unknown[]): void {\n    this.log('warn', ...args);\n  }\n\n  info(...args: unknown[]): void {\n    this.log('info', ...args);\n  }\n\n  debug(...args: unknown[]): void {\n    this.log('debug', ...args);\n  }\n\n  private log(level: keyof Logger, ...args: unknown[]) {\n    try {\n      this.logger[level](...args);\n    } catch (error) {\n      this.fallbackLogger[level](...args);\n    }\n  }\n}\n", "import { Logger, ManageLogger, SafeLogger } from '../logger';\nimport { ProviderEventEmitter } from './provider-event-emitter';\nimport { EventContext, EventDetails, EventHandler } from './eventing';\nimport { AllProviderEvents, AnyProviderEvent } from './events';\n\n/**\n * The GenericEventEmitter should only be used within the SDK. It supports additional properties that can be included\n * in the event details.\n */\nexport abstract class GenericEventEmitter<\n    E extends AnyProviderEvent,\n    AdditionalContext extends Record<string, unknown> = Record<string, unknown>,\n  >\n  implements ProviderEventEmitter<E>, ManageLogger<GenericEventEmitter<E, AdditionalContext>>\n{\n  protected abstract readonly eventEmitter: PlatformEventEmitter;\n\n  private readonly _handlers: { [key in AnyProviderEvent]: WeakMap<EventHandler, EventHandler[]> } = {\n    [AllProviderEvents.ConfigurationChanged]: new WeakMap<EventHandler, EventHandler[]>(),\n    [AllProviderEvents.ContextChanged]: new WeakMap<EventHandler, EventHandler[]>(),\n    [AllProviderEvents.Ready]: new WeakMap<EventHandler, EventHandler[]>(),\n    [AllProviderEvents.Error]: new WeakMap<EventHandler, EventHandler[]>(),\n    [AllProviderEvents.Stale]: new WeakMap<EventHandler, EventHandler[]>(),\n    [AllProviderEvents.Reconciling]: new WeakMap<EventHandler, EventHandler[]>(),\n  };\n  private _eventLogger?: Logger;\n\n  constructor(private readonly globalLogger?: () => Logger) {}\n\n  // here we use E, to restrict the events a provider can manually emit (PROVIDER_CONTEXT_CHANGED is emitted by the SDK)\n  emit(eventType: E, context?: EventContext): void {\n    this.eventEmitter.emit(eventType, context);\n  }\n\n  addHandler(eventType: AnyProviderEvent, handler: EventHandler): void {\n    // The handlers have to be wrapped with an async function because if a synchronous functions throws an error,\n    // the other handlers will not run.\n    const asyncHandler = async (details?: EventDetails) => {\n      try {\n        await handler(details);\n      } catch (err) {\n        this._logger?.error('Error running event handler:', err);\n      }\n    };\n    // The async handler has to be written to the map, because we need to get the wrapper function when deleting a listener\n    const existingAsyncHandlers = this._handlers[eventType].get(handler);\n\n    // we allow duplicate event handlers, similar to node,\n    // see: https://nodejs.org/api/events.html#emitteroneventname-listener\n    // and https://nodejs.org/api/events.html#emitterremovelistenereventname-listener\n    this._handlers[eventType].set(handler, [...(existingAsyncHandlers || []), asyncHandler]);\n    this.eventEmitter.on(eventType, asyncHandler);\n  }\n\n  removeHandler(eventType: AnyProviderEvent, handler: EventHandler): void {\n    // Get the wrapper function for this handler, to delete it from the event emitter\n    const existingAsyncHandlers = this._handlers[eventType].get(handler);\n\n    if (existingAsyncHandlers) {\n      const removedAsyncHandler = existingAsyncHandlers.pop();\n      if (removedAsyncHandler) {\n        this.eventEmitter.removeListener(eventType, removedAsyncHandler);\n      }\n    }\n  }\n\n  removeAllHandlers(eventType?: AnyProviderEvent): void {\n    // If giving undefined, the listeners are not removed, so we have to check explicitly\n    if (eventType) {\n      this.eventEmitter.removeAllListeners(eventType);\n    } else {\n      this.eventEmitter.removeAllListeners();\n    }\n  }\n\n  getHandlers(eventType: AnyProviderEvent): EventHandler[] {\n    return this.eventEmitter.listeners(eventType) as EventHandler[];\n  }\n\n  setLogger(logger: Logger): this {\n    this._eventLogger = new SafeLogger(logger);\n    return this;\n  }\n\n  protected get _logger() {\n    return this._eventLogger ?? this.globalLogger?.();\n  }\n}\n\n/**\n * This is an un-exported type that corresponds to NodeJS.EventEmitter.\n * We can't use that type here, because this module is used in both the browser, and the server.\n * In the server, node (or whatever server runtime) provides an implementation for this.\n * In the browser, we bundle in the popular 'EventEmitter3' package, which is a polyfill of NodeJS.EventEmitter.\n */\n/* eslint-disable */\ninterface PlatformEventEmitter {\n  addListener(eventName: string | symbol, listener: (...args: any[]) => void): this;\n  on(eventName: string | symbol, listener: (...args: any[]) => void): this;\n  once(eventName: string | symbol, listener: (...args: any[]) => void): this;\n  removeListener(eventName: string | symbol, listener: (...args: any[]) => void): this;\n  off(eventName: string | symbol, listener: (...args: any[]) => void): this;\n  removeAllListeners(event?: string | symbol): this;\n  listeners(eventName: string | symbol): Function[];\n  emit(eventName: string | symbol, ...args: any[]): boolean;\n  listenerCount(eventName: string | symbol, listener?: Function): number;\n  eventNames(): Array<string | symbol>;\n}\n", "/**\n * Checks whether the parameter is a string.\n * @param {unknown} value The value to check\n * @returns {value is string} True if the value is a string\n */\nexport function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\n/**\n * Returns the parameter if it is a string, otherwise returns undefined.\n * @param {unknown} value The value to check\n * @returns {string|undefined} The parameter if it is a string, otherwise undefined\n */\nexport function stringOrUndefined(value: unknown): string | undefined {\n  return isString(value) ? value : undefined;\n}\n\n/**\n * Checks whether the parameter is an object.\n * @param {unknown} value The value to check\n * @returns {value is string} True if the value is an object\n */\nexport function isObject<T extends object>(value: unknown): value is T {\n  return typeof value === 'object';\n}\n\n/**\n * Returns the parameter if it is an object, otherwise returns undefined.\n * @param {unknown} value The value to check\n * @returns {object|undefined} The parameter if it is an object, otherwise undefined\n */\nexport function objectOrUndefined<T extends object>(value: unknown): T | undefined {\n  return isObject<T>(value) ? value : undefined;\n}\n", "/**\n * Checks if a value is not null or undefined and returns it as type assertion\n * @template T\n * @param {T} input The value to check\n * @returns {T} If the value is not null or undefined\n */\nexport function isDefined<T>(input?: T | null | undefined): input is T {\n  return typeof input !== 'undefined' && input !== null;\n}\n", "import { GeneralError, OpenFeatureError } from './errors';\nimport { ErrorCode, EvaluationContext } from './evaluation';\nimport {\n  AllProviderEvents,\n  AnyProviderEvent,\n  EventDetails,\n  EventHandler,\n  Eventing,\n  GenericEventEmitter,\n  statusMatchesEvent,\n} from './events';\nimport { isDefined } from './filter';\nimport { BaseHook, EvaluationLifeCycle } from './hooks';\nimport { DefaultLogger, Logger, ManageLogger, SafeLogger } from './logger';\nimport { ClientProviderStatus, CommonProvider, ProviderMetadata, ServerProviderStatus } from './provider';\nimport { objectOrUndefined, stringOrUndefined } from './type-guards';\nimport { Paradigm } from './types';\n\ntype AnyProviderStatus = ClientProviderStatus | ServerProviderStatus;\n\n/**\n * A provider and its current status.\n * For internal use only.\n */\nexport class ProviderWrapper<P extends CommonProvider<AnyProviderStatus>, S extends AnyProviderStatus> {\n  private _pendingContextChanges = 0;\n\n  constructor(\n    private _provider: P,\n    private _status: S,\n    _statusEnumType: typeof ClientProviderStatus | typeof ServerProviderStatus,\n  ) {\n    // update the providers status with events\n    _provider.events?.addHandler(AllProviderEvents.Ready, () => {\n      // These casts are due to the face we don't \"know\" what status enum we are dealing with here (client or server).\n      // We could abstract this an implement it in the client/server libs to fix this, but the value is low.\n      this._status = _statusEnumType.READY as S;\n    });\n    _provider.events?.addHandler(AllProviderEvents.Stale, () => {\n      this._status = _statusEnumType.STALE as S;\n    });\n    _provider.events?.addHandler(AllProviderEvents.Error, (details) => {\n      if (details?.errorCode === ErrorCode.PROVIDER_FATAL) {\n        this._status = _statusEnumType.FATAL as S;\n      } else {\n        this._status = _statusEnumType.ERROR as S;\n      }\n    });\n  }\n\n  get provider(): P {\n    return this._provider;\n  }\n\n  set provider(provider: P) {\n    this._provider = provider;\n  }\n\n  get status(): S {\n    return this._status;\n  }\n\n  set status(status: S) {\n    this._status = status;\n  }\n\n  get allContextChangesSettled() {\n    return this._pendingContextChanges === 0;\n  }\n\n  incrementPendingContextChanges() {\n    this._pendingContextChanges++;\n  }\n\n  decrementPendingContextChanges() {\n    this._pendingContextChanges--;\n  }\n}\n\nexport abstract class OpenFeatureCommonAPI<\n    S extends AnyProviderStatus,\n    P extends CommonProvider<S> = CommonProvider<S>,\n    H extends BaseHook = BaseHook,\n  >\n  implements\n    Eventing<AnyProviderEvent>,\n    EvaluationLifeCycle<OpenFeatureCommonAPI<S, P>>,\n    ManageLogger<OpenFeatureCommonAPI<S, P>>\n{\n  // accessor for the type of the ProviderStatus enum (client or server)\n  protected abstract readonly _statusEnumType: typeof ClientProviderStatus | typeof ServerProviderStatus;\n  protected abstract _createEventEmitter(): GenericEventEmitter<AnyProviderEvent>;\n  protected abstract _defaultProvider: ProviderWrapper<P, AnyProviderStatus>;\n  protected abstract readonly _domainScopedProviders: Map<string, ProviderWrapper<P, AnyProviderStatus>>;\n  protected abstract readonly _apiEmitter: GenericEventEmitter<AnyProviderEvent>;\n\n  protected _hooks: H[] = [];\n  protected _context: EvaluationContext = {};\n  protected _logger: Logger = new DefaultLogger();\n\n  private readonly _clientEventHandlers: Map<string | undefined, [AnyProviderEvent, EventHandler][]> = new Map();\n  protected _domainScopedContext: Map<string, EvaluationContext> = new Map();\n  protected _clientEvents: Map<string | undefined, GenericEventEmitter<AnyProviderEvent>> = new Map();\n  protected _runsOn: Paradigm;\n\n  constructor(category: Paradigm) {\n    this._runsOn = category;\n  }\n\n  addHooks(...hooks: H[]): this {\n    this._hooks = [...this._hooks, ...hooks];\n    return this;\n  }\n\n  getHooks(): H[] {\n    return this._hooks;\n  }\n\n  clearHooks(): this {\n    this._hooks = [];\n    return this;\n  }\n\n  setLogger(logger: Logger): this {\n    this._logger = new SafeLogger(logger);\n    return this;\n  }\n\n  /**\n   * Get metadata about the default provider.\n   * @returns {ProviderMetadata} Provider Metadata\n   */\n  get providerMetadata(): ProviderMetadata {\n    return this.getProviderMetadata();\n  }\n\n  /**\n   * Get metadata about a registered provider using the client name.\n   * An unbound or empty client name will return metadata from the default provider.\n   * @param {string} domain An identifier which logically binds clients with providers\n   * @returns {ProviderMetadata} Provider Metadata\n   */\n  getProviderMetadata(domain?: string): ProviderMetadata {\n    return this.getProviderForClient(domain).metadata;\n  }\n\n  /**\n   * Adds a handler for the given provider event type.\n   * The handlers are called in the order they have been added.\n   * API (global) events run for all providers.\n   * @param {AnyProviderEvent} eventType The provider event type to listen to\n   * @param {EventHandler} handler The handler to run on occurrence of the event type\n   */\n  addHandler<T extends AnyProviderEvent>(eventType: T, handler: EventHandler): void {\n    [...new Map([[undefined, this._defaultProvider]]), ...this._domainScopedProviders].forEach((keyProviderTuple) => {\n      const domain = keyProviderTuple[0];\n      const provider = keyProviderTuple[1].provider;\n      const status = keyProviderTuple[1].status;\n      const shouldRunNow = statusMatchesEvent(eventType, status);\n\n      if (shouldRunNow) {\n        // run immediately, we're in the matching state\n        try {\n          handler({ domain, providerName: provider.metadata.name });\n        } catch (err) {\n          this._logger?.error('Error running event handler:', err);\n        }\n      }\n    });\n\n    this._apiEmitter.addHandler(eventType, handler);\n  }\n\n  /**\n   * Removes a handler for the given provider event type.\n   * @param {AnyProviderEvent} eventType The provider event type to remove the listener for\n   * @param {EventHandler} handler The handler to remove for the provider event type\n   */\n  removeHandler<T extends AnyProviderEvent>(eventType: T, handler: EventHandler): void {\n    this._apiEmitter.removeHandler(eventType, handler);\n  }\n\n  /**\n   * Removes all event handlers.\n   */\n  clearHandlers(): void {\n    this._apiEmitter.removeAllHandlers();\n  }\n\n  /**\n   * Gets the current handlers for the given provider event type.\n   * @param {AnyProviderEvent} eventType The provider event type to get the current handlers for\n   * @returns {EventHandler[]} The handlers currently attached to the given provider event type\n   */\n  getHandlers<T extends AnyProviderEvent>(eventType: T): EventHandler[] {\n    return this._apiEmitter.getHandlers(eventType);\n  }\n\n  abstract setProviderAndWait(\n    clientOrProvider?: string | P,\n    providerContextOrUndefined?: P | EvaluationContext,\n    contextOrUndefined?: EvaluationContext,\n  ): Promise<void>;\n\n  abstract setProvider(\n    clientOrProvider?: string | P,\n    providerContextOrUndefined?: P | EvaluationContext,\n    contextOrUndefined?: EvaluationContext,\n  ): this;\n\n  protected setAwaitableProvider(domainOrProvider?: string | P, providerOrUndefined?: P): Promise<void> | void {\n    const domain = stringOrUndefined(domainOrProvider);\n    const provider = objectOrUndefined<P>(domainOrProvider) ?? objectOrUndefined<P>(providerOrUndefined);\n\n    if (!provider) {\n      this._logger.debug('No provider defined, ignoring setProvider call');\n      return;\n    }\n\n    const oldProvider = this.getProviderForClient(domain);\n    const providerName = provider.metadata.name;\n\n    // ignore no-ops\n    if (oldProvider === provider) {\n      this._logger.debug('Provider is already set, ignoring setProvider call');\n      return;\n    }\n\n    if (!provider.runsOn) {\n      this._logger.debug(`Provider '${provider.metadata.name}' has not defined its intended use.`);\n    } else if (provider.runsOn !== this._runsOn) {\n      throw new GeneralError(`Provider '${provider.metadata.name}' is intended for use on the ${provider.runsOn}.`);\n    }\n\n    const emitters = this.getAssociatedEventEmitters(domain);\n\n    let initializationPromise: Promise<void> | void = undefined;\n    const wrappedProvider = new ProviderWrapper<P, AnyProviderStatus>(\n      provider,\n      this._statusEnumType.NOT_READY,\n      this._statusEnumType,\n    );\n\n    // initialize the provider if it implements \"initialize\" and it's not already registered\n    if (typeof provider.initialize === 'function' && !this.allProviders.includes(provider)) {\n      initializationPromise = provider\n        .initialize?.(domain ? this._domainScopedContext.get(domain) ?? this._context : this._context)\n        ?.then(() => {\n          wrappedProvider.status = this._statusEnumType.READY;\n          // fetch the most recent event emitters, some may have been added during init\n          this.getAssociatedEventEmitters(domain).forEach((emitter) => {\n            emitter?.emit(AllProviderEvents.Ready, { clientName: domain, domain, providerName });\n          });\n          this._apiEmitter?.emit(AllProviderEvents.Ready, { clientName: domain, domain, providerName });\n        })\n        ?.catch((error) => {\n          // if this is a fatal error, transition to FATAL status\n          if ((error as OpenFeatureError)?.code === ErrorCode.PROVIDER_FATAL) {\n            wrappedProvider.status = this._statusEnumType.FATAL;\n          } else {\n            wrappedProvider.status = this._statusEnumType.ERROR;\n          }\n          this.getAssociatedEventEmitters(domain).forEach((emitter) => {\n            emitter?.emit(AllProviderEvents.Error, {\n              clientName: domain,\n              domain,\n              providerName,\n              message: error?.message,\n            });\n          });\n          this._apiEmitter?.emit(AllProviderEvents.Error, {\n            clientName: domain,\n            domain,\n            providerName,\n            message: error?.message,\n          });\n          // rethrow after emitting error events, so that public methods can control error handling\n          throw error;\n        });\n    } else {\n      wrappedProvider.status = this._statusEnumType.READY;\n      emitters.forEach((emitter) => {\n        emitter?.emit(AllProviderEvents.Ready, { clientName: domain, domain, providerName });\n      });\n      this._apiEmitter?.emit(AllProviderEvents.Ready, { clientName: domain, domain, providerName });\n    }\n\n    if (domain) {\n      this._domainScopedProviders.set(domain, wrappedProvider);\n    } else {\n      this._defaultProvider = wrappedProvider;\n    }\n\n    this.transferListeners(oldProvider, provider, domain, emitters);\n\n    // Do not close a provider that is bound to any client\n    if (!this.allProviders.includes(oldProvider)) {\n      oldProvider?.onClose?.()?.catch((err: Error | undefined) => {\n        this._logger.error(`error closing provider: ${err?.message}, ${err?.stack}`);\n      });\n    }\n\n    return initializationPromise;\n  }\n\n  protected getProviderForClient(domain?: string): P {\n    if (!domain) {\n      return this._defaultProvider.provider;\n    }\n\n    return this._domainScopedProviders.get(domain)?.provider ?? this._defaultProvider.provider;\n  }\n\n  protected buildAndCacheEventEmitterForClient(domain?: string): GenericEventEmitter<AnyProviderEvent> {\n    const emitter = this._clientEvents.get(domain);\n\n    if (emitter) {\n      return emitter;\n    }\n\n    // lazily add the event emitters\n    const newEmitter = this._createEventEmitter();\n    this._clientEvents.set(domain, newEmitter);\n\n    const clientProvider = this.getProviderForClient(domain);\n    Object.values<AllProviderEvents>(AllProviderEvents).forEach((eventType) =>\n      clientProvider.events?.addHandler(eventType, async (details) => {\n        newEmitter.emit(eventType, {\n          ...details,\n          clientName: domain,\n          domain,\n          providerName: clientProvider.metadata.name,\n        });\n      }),\n    );\n\n    return newEmitter;\n  }\n\n  private getUnboundEmitters(): GenericEventEmitter<AnyProviderEvent>[] {\n    const domainScopedProviders = [...this._domainScopedProviders.keys()];\n    const eventEmitterNames = [...this._clientEvents.keys()].filter(isDefined);\n    const unboundEmitterNames = eventEmitterNames.filter((name) => !domainScopedProviders.includes(name));\n    return [\n      // all unbound, named emitters\n      ...unboundEmitterNames.map((name) => this._clientEvents.get(name)),\n      // the default emitter\n      this._clientEvents.get(undefined),\n    ].filter(isDefined);\n  }\n\n  protected getAssociatedEventEmitters(domain: string | undefined) {\n    return domain ? [this.buildAndCacheEventEmitterForClient(domain)] : this.getUnboundEmitters();\n  }\n\n  private transferListeners(\n    oldProvider: P,\n    newProvider: P,\n    domain: string | undefined,\n    emitters: (GenericEventEmitter<AnyProviderEvent> | undefined)[],\n  ) {\n    this._clientEventHandlers\n      .get(domain)\n      ?.forEach((eventHandler) => oldProvider.events?.removeHandler(...eventHandler));\n\n    // iterate over the event types\n    const newClientHandlers = Object.values(AllProviderEvents).map<[AllProviderEvents, EventHandler]>((eventType) => {\n      const handler = async (details?: EventDetails) => {\n        // on each event type, fire the associated handlers\n        emitters.forEach((emitter) => {\n          emitter?.emit(eventType, { ...details, clientName: domain, domain, providerName: newProvider.metadata.name });\n        });\n        this._apiEmitter.emit(eventType, {\n          ...details,\n          clientName: domain,\n          domain,\n          providerName: newProvider.metadata.name,\n        });\n      };\n\n      return [eventType, handler];\n    });\n\n    this._clientEventHandlers.set(domain, newClientHandlers);\n    newClientHandlers.forEach((eventHandler) => newProvider.events?.addHandler(...eventHandler));\n  }\n\n  async close(): Promise<void> {\n    try {\n      await this?._defaultProvider.provider?.onClose?.();\n    } catch (err) {\n      this.handleShutdownError(this._defaultProvider.provider, err);\n    }\n\n    const wrappers = Array.from(this._domainScopedProviders);\n\n    await Promise.all(\n      wrappers.map(async ([, wrapper]) => {\n        try {\n          await wrapper?.provider.onClose?.();\n        } catch (err) {\n          this.handleShutdownError(wrapper?.provider, err);\n        }\n      }),\n    );\n  }\n\n  protected async clearProvidersAndSetDefault(defaultProvider: P): Promise<void> {\n    try {\n      await this.close();\n    } catch (err) {\n      this._logger.error('Unable to cleanly close providers. Resetting to the default configuration.');\n    } finally {\n      this._domainScopedProviders.clear();\n      this._defaultProvider = new ProviderWrapper<P, AnyProviderStatus>(\n        defaultProvider,\n        this._statusEnumType.NOT_READY,\n        this._statusEnumType,\n      );\n    }\n  }\n\n  private get allProviders(): P[] {\n    return [\n      ...[...this._domainScopedProviders.values()].map((wrappers) => wrappers.provider),\n      this._defaultProvider.provider,\n    ];\n  }\n\n  private handleShutdownError(provider: P, err: unknown) {\n    this._logger.error(`Error during shutdown of provider ${provider.metadata.name}: ${err}`);\n    this._logger.error((err as Error)?.stack);\n  }\n}\n"],
  "mappings": "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",
  "names": ["ErrorCode", "ServerProviderStatus", "ClientProviderStatus", "ServerProviderEvents", "ClientProviderEvents", "_a", "_b"]
}
