"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const http = require("http");
const https = require("https");
const createHttpsProxyAgent = require("https-proxy-agent");
// No types for the event source.
// @ts-ignore
const launchdarkly_eventsource_1 = require("launchdarkly-eventsource");
const NodeResponse_1 = require("./NodeResponse");
function processTlsOptions(tlsOptions) {
    const options = {
        ca: tlsOptions.ca,
        cert: tlsOptions.cert,
        checkServerIdentity: tlsOptions.checkServerIdentity,
        ciphers: tlsOptions.ciphers,
        // Our interface says object for the pfx object. But the node
        // type is more strict. This is also true for the key and KeyObject.
        // @ts-ignore
        pfx: tlsOptions.pfx,
        // @ts-ignore
        key: tlsOptions.key,
        passphrase: tlsOptions.passphrase,
        rejectUnauthorized: tlsOptions.rejectUnauthorized,
        secureProtocol: tlsOptions.secureProtocol,
        servername: tlsOptions.servername,
    };
    // Node does not take kindly to undefined keys.
    Object.keys(options).forEach((key) => {
        if (options[key] === undefined) {
            delete options[key];
        }
    });
    return options;
}
function processProxyOptions(proxyOptions, additional = {}) {
    var _a;
    const protocol = ((_a = proxyOptions.scheme) === null || _a === void 0 ? void 0 : _a.startsWith('https')) ? 'https:' : 'http';
    const parsedOptions = Object.assign({ port: proxyOptions.port, host: proxyOptions.host, protocol }, additional);
    if (proxyOptions.auth) {
        parsedOptions.headers = {
            'Proxy-Authorization': `Basic ${Buffer.from(proxyOptions.auth).toString('base64')}}`,
        };
    }
    // Node does not take kindly to undefined keys.
    Object.keys(parsedOptions).forEach((key) => {
        if (parsedOptions[key] === undefined) {
            delete parsedOptions[key];
        }
    });
    return createHttpsProxyAgent(parsedOptions);
}
function createAgent(tlsOptions, proxyOptions, logger) {
    var _a;
    if (!((_a = proxyOptions === null || proxyOptions === void 0 ? void 0 : proxyOptions.auth) === null || _a === void 0 ? void 0 : _a.startsWith('https')) && tlsOptions) {
        logger === null || logger === void 0 ? void 0 : logger.warn('Proxy configured with TLS options, but is not using an https auth.');
    }
    if (tlsOptions) {
        const agentOptions = processTlsOptions(tlsOptions);
        if (proxyOptions) {
            return processProxyOptions(proxyOptions, agentOptions);
        }
        return new https.Agent(agentOptions);
    }
    if (proxyOptions) {
        return processProxyOptions(proxyOptions);
    }
    return undefined;
}
class NodeRequests {
    constructor(tlsOptions, proxyOptions, logger) {
        this.hasProxy = false;
        this.hasProxyAuth = false;
        this.agent = createAgent(tlsOptions, proxyOptions, logger);
        this.hasProxy = !!proxyOptions;
        this.hasProxyAuth = !!(proxyOptions === null || proxyOptions === void 0 ? void 0 : proxyOptions.auth);
    }
    fetch(url, options = {}) {
        var _a;
        const isSecure = url.startsWith('https://');
        const impl = isSecure ? https : http;
        // For get requests we are going to automatically support compressed responses.
        // Note this does not affect SSE as the event source is not using this fetch implementation.
        const headers = ((_a = options.method) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'get'
            ? Object.assign(Object.assign({}, options.headers), { 'accept-encoding': 'gzip' }) : options.headers;
        return new Promise((resolve, reject) => {
            const req = impl.request(url, {
                timeout: options.timeout,
                headers,
                method: options.method,
                agent: this.agent,
            }, (res) => resolve(new NodeResponse_1.default(res)));
            if (options.body) {
                req.write(options.body);
            }
            req.on('error', (err) => {
                reject(err);
            });
            req.end();
        });
    }
    createEventSource(url, eventSourceInitDict) {
        const expandedOptions = Object.assign(Object.assign({}, eventSourceInitDict), { agent: this.agent, tlsParams: this.tlsOptions, maxBackoffMillis: 30 * 1000, jitterRatio: 0.5 });
        return new launchdarkly_eventsource_1.EventSource(url, expandedOptions);
    }
    usingProxy() {
        return this.hasProxy;
    }
    usingProxyAuth() {
        return this.hasProxyAuth;
    }
}
exports.default = NodeRequests;
//# sourceMappingURL=NodeRequests.js.map