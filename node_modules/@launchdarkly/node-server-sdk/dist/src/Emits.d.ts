/// <reference types="node" />
import { EventEmitter } from 'events';
export type EventableConstructor<T = {}> = new (...args: any[]) => T;
export type Eventable = EventableConstructor<{
    emitter: EventEmitter;
}>;
/**
 * Adds the implementation of an event emitter to something that contains
 * a field of `emitter` with type `EventEmitter`.
 * @param Base The class to derive the mixin from.
 * @returns A class extending the base with an event emitter.
 */
export declare function Emits<TBase extends Eventable>(Base: TBase): {
    new (...args: any[]): {
        on(eventName: string | symbol, listener: (...args: any[]) => void): this;
        addListener(eventName: string | symbol, listener: (...args: any[]) => void): this;
        once(eventName: string | symbol, listener: (...args: any[]) => void): this;
        removeListener(eventName: string | symbol, listener: (...args: any[]) => void): this;
        off(eventName: string | symbol, listener: (...args: any) => void): this;
        removeAllListeners(event?: string | symbol): this;
        setMaxListeners(n: number): this;
        getMaxListeners(): number;
        listeners(eventName: string | symbol): Function[];
        rawListeners(eventName: string | symbol): Function[];
        emit(eventName: string | symbol, ...args: any[]): boolean;
        listenerCount(eventName: string | symbol): number;
        prependListener(eventName: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(eventName: string | symbol, listener: (...args: any[]) => void): this;
        eventNames(): (string | symbol)[];
        emitter: EventEmitter<[never]>;
    };
} & TBase;
//# sourceMappingURL=Emits.d.ts.map