import { LDContextCommon } from './api/context/LDContextCommon';
export default class AttributeReference {
    readonly isValid: boolean;
    /**
     * When redacting attributes this name can be directly added to the list of
     * redactions.
     */
    readonly redactionName: string;
    /**
     * For use as invalid references when deserializing Flag/Segment data.
     */
    static readonly invalidReference: AttributeReference;
    private readonly components;
    /**
     * Take an attribute reference string, or literal string, and produce
     * an attribute reference.
     *
     * Legacy user objects would have been created with names not
     * references. So, in that case, we need to use them as a component
     * without escaping them.
     *
     * e.g. A user could contain a custom attribute of `/a` which would
     * become the literal `a` if treated as a reference. Which would cause
     * it to no longer be redacted.
     * @param refOrLiteral The attribute reference string or literal string.
     * @param literal it true the value should be treated as a literal.
     */
    constructor(refOrLiteral: string, literal?: boolean);
    get(target: LDContextCommon): LDContextCommon | undefined;
    getComponent(depth: number): string;
    get depth(): number;
    get isKind(): boolean;
    compare(other: AttributeReference): boolean;
}
//# sourceMappingURL=AttributeReference.d.ts.map