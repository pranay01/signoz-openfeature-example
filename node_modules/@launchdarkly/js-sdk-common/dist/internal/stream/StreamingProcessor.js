"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../../errors");
const utils_1 = require("../../utils");
const reportJsonError = (type, data, logger, errorHandler) => {
    logger === null || logger === void 0 ? void 0 : logger.error(`Stream received invalid data in "${type}" message`);
    logger === null || logger === void 0 ? void 0 : logger.debug(`Invalid JSON follows: ${data}`);
    errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(new errors_1.LDStreamingError('Malformed JSON data in event stream'));
};
class StreamingProcessor {
    constructor(sdkKey, clientContext, streamUriPath, listeners, diagnosticsManager, errorHandler, streamInitialReconnectDelay = 1) {
        this.listeners = listeners;
        this.diagnosticsManager = diagnosticsManager;
        this.errorHandler = errorHandler;
        this.streamInitialReconnectDelay = streamInitialReconnectDelay;
        const { basicConfiguration, platform } = clientContext;
        const { logger, tags } = basicConfiguration;
        const { info, requests } = platform;
        this.headers = (0, utils_1.defaultHeaders)(sdkKey, info, tags);
        this.logger = logger;
        this.requests = requests;
        this.streamUri = `${basicConfiguration.serviceEndpoints.streaming}${streamUriPath}`;
    }
    logConnectionStarted() {
        this.connectionAttemptStartTime = Date.now();
    }
    logConnectionResult(success) {
        if (this.connectionAttemptStartTime && this.diagnosticsManager) {
            this.diagnosticsManager.recordStreamInit(this.connectionAttemptStartTime, !success, Date.now() - this.connectionAttemptStartTime);
        }
        this.connectionAttemptStartTime = undefined;
    }
    /**
     * This is a wrapper around the passed errorHandler which adds additional
     * diagnostics and logging logic.
     *
     * @param err The error to be logged and handled.
     * @return boolean whether to retry the connection.
     *
     * @private
     */
    retryAndHandleError(err) {
        var _a, _b, _c;
        if (!(0, utils_1.shouldRetry)(err)) {
            this.logConnectionResult(false);
            (_a = this.errorHandler) === null || _a === void 0 ? void 0 : _a.call(this, new errors_1.LDStreamingError(err.message, err.status));
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.error((0, utils_1.httpErrorMessage)(err, 'streaming request'));
            return false;
        }
        (_c = this.logger) === null || _c === void 0 ? void 0 : _c.warn((0, utils_1.httpErrorMessage)(err, 'streaming request', 'will retry'));
        this.logConnectionResult(false);
        this.logConnectionStarted();
        return true;
    }
    start() {
        this.logConnectionStarted();
        // TLS is handled by the platform implementation.
        const eventSource = this.requests.createEventSource(this.streamUri, {
            headers: this.headers,
            errorFilter: (error) => this.retryAndHandleError(error),
            initialRetryDelayMillis: 1000 * this.streamInitialReconnectDelay,
            readTimeoutMillis: 5 * 60 * 1000,
            retryResetIntervalMillis: 60 * 1000,
        });
        this.eventSource = eventSource;
        eventSource.onclose = () => {
            var _a;
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info('Closed LaunchDarkly stream connection');
        };
        eventSource.onerror = () => {
            // The work is done by `errorFilter`.
        };
        eventSource.onopen = () => {
            var _a;
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info('Opened LaunchDarkly stream connection');
        };
        eventSource.onretrying = (e) => {
            var _a;
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info(`Will retry stream connection in ${e.delayMillis} milliseconds`);
        };
        this.listeners.forEach(({ deserializeData, processJson }, eventName) => {
            eventSource.addEventListener(eventName, (event) => {
                var _a, _b;
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug(`Received ${eventName} event`);
                if (event === null || event === void 0 ? void 0 : event.data) {
                    this.logConnectionResult(true);
                    const { data } = event;
                    const dataJson = deserializeData(data);
                    if (!dataJson) {
                        reportJsonError(eventName, data, this.logger, this.errorHandler);
                        return;
                    }
                    processJson(dataJson);
                }
                else {
                    (_b = this.errorHandler) === null || _b === void 0 ? void 0 : _b.call(this, new errors_1.LDStreamingError('Unexpected payload from event stream'));
                }
            });
        });
    }
    stop() {
        var _a;
        (_a = this.eventSource) === null || _a === void 0 ? void 0 : _a.close();
        this.eventSource = undefined;
    }
    close() {
        this.stop();
    }
}
exports.default = StreamingProcessor;
//# sourceMappingURL=StreamingProcessor.js.map