"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("../events");
class EventFactoryBase {
    constructor(withReasons) {
        this.withReasons = withReasons;
    }
    evalEvent(e) {
        var _a;
        return new events_1.InputEvalEvent(this.withReasons, e.context, e.flagKey, e.value, e.defaultVal, e.version, 
        // Exclude null as a possibility.
        (_a = e.variation) !== null && _a !== void 0 ? _a : undefined, e.trackEvents || e.addExperimentData, e.prereqOfFlagKey, this.withReasons || e.addExperimentData ? e.reason : undefined, e.debugEventsUntilDate, e.excludeFromSummaries, e.samplingRatio);
    }
    unknownFlagEvent(key, defVal, context) {
        return new events_1.InputEvalEvent(this.withReasons, context, key, defVal, defVal, 
        // This isn't ideal, but the purpose of the factory is to at least
        // handle this situation.
        undefined, // version
        undefined, // variation index
        undefined, // track events
        undefined, // prereqOf
        undefined, // reason
        undefined, // debugEventsUntilDate
        undefined, // exclude from summaries
        undefined);
    }
    /* eslint-disable-next-line class-methods-use-this */
    identifyEvent(context) {
        // Currently sampling for identify events is always 1.
        return new events_1.InputIdentifyEvent(context, 1);
    }
    /* eslint-disable-next-line class-methods-use-this */
    customEvent(key, context, data, metricValue, samplingRatio = 1) {
        return new events_1.InputCustomEvent(context, key, data !== null && data !== void 0 ? data : undefined, metricValue !== null && metricValue !== void 0 ? metricValue : undefined, samplingRatio);
    }
}
exports.default = EventFactoryBase;
//# sourceMappingURL=EventFactoryBase.js.map