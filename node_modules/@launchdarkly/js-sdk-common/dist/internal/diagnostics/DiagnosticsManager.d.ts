import { Platform } from '../../api';
import { DiagnosticInitEvent, DiagnosticStatsEvent } from './types';
export default class DiagnosticsManager {
    private readonly platform;
    private readonly diagnosticInitConfig;
    private readonly startTime;
    private streamInits;
    private readonly id;
    private dataSinceDate;
    constructor(sdkKey: string, platform: Platform, diagnosticInitConfig: any);
    /**
     * Creates the initial event that is sent by the event processor when the SDK starts up. This will
     * not be repeated during the lifetime of the SDK client.
     */
    createInitEvent(): DiagnosticInitEvent;
    /**
     * Records a stream connection attempt (called by the stream processor).
     *
     * @param timestamp Time of the *beginning* of the connection attempt.
     * @param failed True if the connection failed, or we got a read timeout before receiving a "put".
     * @param durationMillis Elapsed time between starting timestamp and when we either gave up/lost
     * the connection or received a successful "put".
     */
    recordStreamInit(timestamp: number, failed: boolean, durationMillis: number): void;
    /**
     * Creates a periodic event containing time-dependent stats, and resets the state of the manager
     * with regard to those stats.
     *
     * Note: the reason droppedEvents, deduplicatedUsers, and eventsInLastBatch are passed into this
     * function, instead of being properties of the DiagnosticsManager, is that the event processor is
     * the one who's calling this function and is also the one who's tracking those stats.
     */
    createStatsEventAndReset(droppedEvents: number, deduplicatedUsers: number, eventsInLastBatch: number): DiagnosticStatsEvent;
}
//# sourceMappingURL=DiagnosticsManager.d.ts.map