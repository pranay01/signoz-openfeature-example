"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const subsystem_1 = require("../../api/subsystem");
const AttributeReference_1 = require("../../AttributeReference");
const ContextFilter_1 = require("../../ContextFilter");
const EventSender_1 = require("./EventSender");
const EventSummarizer_1 = require("./EventSummarizer");
const guards_1 = require("./guards");
const LDInvalidSDKKeyError_1 = require("./LDInvalidSDKKeyError");
const sampling_1 = require("./sampling");
class EventProcessor {
    constructor(config, clientContext, contextDeduplicator, diagnosticsManager, start = true) {
        this.config = config;
        this.contextDeduplicator = contextDeduplicator;
        this.diagnosticsManager = diagnosticsManager;
        this.summarizer = new EventSummarizer_1.default();
        this.queue = [];
        this.lastKnownPastTime = 0;
        this.droppedEvents = 0;
        this.deduplicatedUsers = 0;
        this.exceededCapacity = false;
        this.eventsInLastBatch = 0;
        this.shutdown = false;
        this.flushUsersTimer = null;
        this.capacity = config.eventsCapacity;
        this.logger = clientContext.basicConfiguration.logger;
        this.eventSender = new EventSender_1.default(clientContext);
        this.contextFilter = new ContextFilter_1.default(config.allAttributesPrivate, config.privateAttributes.map((ref) => new AttributeReference_1.default(ref)));
        if (start) {
            this.start();
        }
    }
    start() {
        var _a, _b;
        if (((_a = this.contextDeduplicator) === null || _a === void 0 ? void 0 : _a.flushInterval) !== undefined) {
            this.flushUsersTimer = setInterval(() => {
                var _a;
                (_a = this.contextDeduplicator) === null || _a === void 0 ? void 0 : _a.flush();
            }, this.contextDeduplicator.flushInterval * 1000);
        }
        this.flushTimer = setInterval(async () => {
            var _a;
            try {
                await this.flush();
            }
            catch (e) {
                // Log errors and swallow them
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug(`Flush failed: ${e}`);
            }
        }, this.config.flushInterval * 1000);
        if (this.diagnosticsManager) {
            const initEvent = this.diagnosticsManager.createInitEvent();
            this.postDiagnosticEvent(initEvent);
            this.diagnosticsTimer = setInterval(() => {
                const statsEvent = this.diagnosticsManager.createStatsEventAndReset(this.droppedEvents, this.deduplicatedUsers, this.eventsInLastBatch);
                this.droppedEvents = 0;
                this.deduplicatedUsers = 0;
                this.postDiagnosticEvent(statsEvent);
            }, this.config.diagnosticRecordingInterval * 1000);
        }
        (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug('Started EventProcessor.');
    }
    postDiagnosticEvent(event) {
        this.eventSender.sendEventData(subsystem_1.LDEventType.DiagnosticEvent, event);
    }
    close() {
        clearInterval(this.flushTimer);
        if (this.flushUsersTimer) {
            clearInterval(this.flushUsersTimer);
        }
        if (this.diagnosticsTimer) {
            clearInterval(this.diagnosticsTimer);
        }
    }
    async flush() {
        var _a;
        if (this.shutdown) {
            throw new LDInvalidSDKKeyError_1.default('Events cannot be posted because a permanent error has been encountered. ' +
                'This is most likely an invalid SDK key. The specific error information ' +
                'is logged independently.');
        }
        const eventsToFlush = this.queue;
        this.queue = [];
        const summary = this.summarizer.getSummary();
        this.summarizer.clearSummary();
        if (Object.keys(summary.features).length) {
            eventsToFlush.push(summary);
        }
        if (!eventsToFlush.length) {
            return;
        }
        this.eventsInLastBatch = eventsToFlush.length;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug('Flushing %d events', eventsToFlush.length);
        await this.tryPostingEvents(eventsToFlush);
    }
    sendEvent(inputEvent) {
        var _a;
        if (this.shutdown) {
            return;
        }
        if ((0, guards_1.isMigration)(inputEvent)) {
            // These conditions are not combined, because we always want to stop
            // processing at this point for a migration event. It cannot generate
            // an index event or debug event.
            if ((0, sampling_1.default)(inputEvent.samplingRatio)) {
                const migrationEvent = Object.assign({}, inputEvent);
                if (migrationEvent.samplingRatio === 1) {
                    delete migrationEvent.samplingRatio;
                }
                this.enqueue(migrationEvent);
            }
            return;
        }
        this.summarizer.summarizeEvent(inputEvent);
        const isFeatureEvent = (0, guards_1.isFeature)(inputEvent);
        const addFullEvent = (isFeatureEvent && inputEvent.trackEvents) || !isFeatureEvent;
        const addDebugEvent = this.shouldDebugEvent(inputEvent);
        const isIdentifyEvent = (0, guards_1.isIdentify)(inputEvent);
        const shouldNotDeduplicate = (_a = this.contextDeduplicator) === null || _a === void 0 ? void 0 : _a.processContext(inputEvent.context);
        // If there is no cache, then it will never be in the cache.
        if (!shouldNotDeduplicate) {
            if (!isIdentifyEvent) {
                this.deduplicatedUsers += 1;
            }
        }
        const addIndexEvent = shouldNotDeduplicate && !isIdentifyEvent;
        if (addIndexEvent) {
            this.enqueue(this.makeOutputEvent({
                kind: 'index',
                creationDate: inputEvent.creationDate,
                context: inputEvent.context,
                samplingRatio: 1,
            }, false));
        }
        if (addFullEvent && (0, sampling_1.default)(inputEvent.samplingRatio)) {
            this.enqueue(this.makeOutputEvent(inputEvent, false));
        }
        if (addDebugEvent && (0, sampling_1.default)(inputEvent.samplingRatio)) {
            this.enqueue(this.makeOutputEvent(inputEvent, true));
        }
    }
    makeOutputEvent(event, debug) {
        switch (event.kind) {
            case 'feature': {
                const out = {
                    kind: debug ? 'debug' : 'feature',
                    creationDate: event.creationDate,
                    context: this.contextFilter.filter(event.context, !debug),
                    key: event.key,
                    value: event.value,
                    default: event.default,
                };
                if (event.samplingRatio !== 1) {
                    out.samplingRatio = event.samplingRatio;
                }
                if (event.prereqOf) {
                    out.prereqOf = event.prereqOf;
                }
                if (event.variation !== undefined) {
                    out.variation = event.variation;
                }
                if (event.version !== undefined) {
                    out.version = event.version;
                }
                if (event.reason) {
                    out.reason = event.reason;
                }
                return out;
            }
            case 'index': // Intentional fallthrough.
            case 'identify': {
                const out = {
                    kind: event.kind,
                    creationDate: event.creationDate,
                    context: this.contextFilter.filter(event.context),
                };
                if (event.samplingRatio !== 1) {
                    out.samplingRatio = event.samplingRatio;
                }
                return out;
            }
            case 'custom': {
                const out = {
                    kind: 'custom',
                    creationDate: event.creationDate,
                    key: event.key,
                    contextKeys: event.context.kindsAndKeys,
                };
                if (event.samplingRatio !== 1) {
                    out.samplingRatio = event.samplingRatio;
                }
                if (event.data !== undefined) {
                    out.data = event.data;
                }
                if (event.metricValue !== undefined) {
                    out.metricValue = event.metricValue;
                }
                return out;
            }
            default:
                // This would happen during the addition of a new event type to the SDK.
                return event;
        }
    }
    enqueue(event) {
        var _a;
        if (this.queue.length < this.capacity) {
            this.queue.push(event);
            this.exceededCapacity = false;
        }
        else {
            if (!this.exceededCapacity) {
                this.exceededCapacity = true;
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn('Exceeded event queue capacity. Increase capacity to avoid dropping events.');
            }
            this.droppedEvents += 1;
        }
    }
    shouldDebugEvent(event) {
        return ((0, guards_1.isFeature)(event) &&
            event.debugEventsUntilDate &&
            event.debugEventsUntilDate > this.lastKnownPastTime &&
            event.debugEventsUntilDate > Date.now());
    }
    async tryPostingEvents(events) {
        const res = await this.eventSender.sendEventData(subsystem_1.LDEventType.AnalyticsEvents, events);
        if (res.status === subsystem_1.LDDeliveryStatus.FailedAndMustShutDown) {
            this.shutdown = true;
        }
        if (res.serverTime) {
            this.lastKnownPastTime = res.serverTime;
        }
        if (res.error) {
            throw res.error;
        }
    }
}
exports.default = EventProcessor;
//# sourceMappingURL=EventProcessor.js.map