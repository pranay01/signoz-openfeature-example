"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const subsystem_1 = require("../../api/subsystem");
const errors_1 = require("../../errors");
const utils_1 = require("../../utils");
class EventSender {
    constructor(clientContext) {
        const { basicConfiguration, platform } = clientContext;
        const { sdkKey, serviceEndpoints: { events, analyticsEventPath, diagnosticEventPath, includeAuthorizationHeader, }, tags, } = basicConfiguration;
        const { crypto, info, requests } = platform;
        this.defaultHeaders = (0, utils_1.defaultHeaders)(sdkKey, info, tags, includeAuthorizationHeader);
        this.eventsUri = `${events}${analyticsEventPath}`;
        this.diagnosticEventsUri = `${events}${diagnosticEventPath}`;
        this.requests = requests;
        this.crypto = crypto;
    }
    async tryPostingEvents(events, uri, payloadId, canRetry) {
        const tryRes = {
            status: subsystem_1.LDDeliveryStatus.Succeeded,
        };
        const headers = Object.assign(Object.assign({}, this.defaultHeaders), { 'content-type': 'application/json' });
        if (payloadId) {
            headers['x-launchdarkly-payload-id'] = payloadId;
            headers['x-launchDarkly-event-schema'] = '4';
        }
        let error;
        try {
            const { status, headers: resHeaders } = await this.requests.fetch(uri, {
                headers,
                body: JSON.stringify(events),
                method: 'POST',
            });
            const serverDate = Date.parse(resHeaders.get('date') || '');
            if (serverDate) {
                tryRes.serverTime = serverDate;
            }
            if (status <= 204) {
                return tryRes;
            }
            error = new errors_1.LDUnexpectedResponseError((0, utils_1.httpErrorMessage)({ status, message: 'some events were dropped' }, 'event posting'));
            if (!(0, errors_1.isHttpRecoverable)(status)) {
                // If the HTTP request isn't recoverable. Meaning if we made the same request it
                // would not recover, then we check if a different request could recover.
                // If a different request could not recover, then we shutdown. If a different request could
                // recover, then we just don't retry this specific request.
                if (!(0, errors_1.isHttpLocallyRecoverable)(status)) {
                    tryRes.status = subsystem_1.LDDeliveryStatus.FailedAndMustShutDown;
                }
                else {
                    tryRes.status = subsystem_1.LDDeliveryStatus.Failed;
                }
                tryRes.error = error;
                return tryRes;
            }
        }
        catch (err) {
            error = err;
        }
        // recoverable but not retrying
        if (error && !canRetry) {
            tryRes.status = subsystem_1.LDDeliveryStatus.Failed;
            tryRes.error = error;
            return tryRes;
        }
        // wait 1 second before retrying
        await (0, utils_1.sleep)();
        return this.tryPostingEvents(events, this.eventsUri, payloadId, false);
    }
    async sendEventData(type, data) {
        const payloadId = type === subsystem_1.LDEventType.AnalyticsEvents ? this.crypto.randomUUID() : undefined;
        const uri = type === subsystem_1.LDEventType.AnalyticsEvents ? this.eventsUri : this.diagnosticEventsUri;
        return this.tryPostingEvents(data, uri, payloadId, true);
    }
}
exports.default = EventSender;
//# sourceMappingURL=EventSender.js.map