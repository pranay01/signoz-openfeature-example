"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AttributeReference_1 = require("./AttributeReference");
const context_1 = require("./internal/context");
const validators_1 = require("./validators");
// The general strategy for the context is to transform the passed in context
// as little as possible. We do convert the legacy users to a single kind
// context, but we do not translate all passed contexts into a rigid structure.
// The context will have to be copied for events, but we want to avoid any
// copying that we can.
// So we validate that the information we are given is correct, and then we
// just proxy calls with a nicely typed interface.
// This is to reduce work on the hot-path. Later, for event processing, deeper
// cloning of the context will be done.
// When no kind is specified, then this kind will be used.
const DEFAULT_KIND = 'user';
// The API allows for calling with an `LDContext` which is
// `LDUser | LDSingleKindContext | LDMultiKindContext`. When ingesting a context
// first the type must be determined to allow us to put it into a consistent type.
/**
 * The partial URL encoding is needed because : is a valid character in context keys.
 *
 * Partial encoding is the replacement of all colon (:) characters with the URL
 * encoded equivalent (%3A) and all percent (%) characters with the URL encoded
 * equivalent (%25).
 * @param key The key to encode.
 * @returns Partially URL encoded key.
 */
function encodeKey(key) {
    if (key.includes('%') || key.includes(':')) {
        return key.replace(/%/g, '%25').replace(/:/g, '%3A');
    }
    return key;
}
/**
 * Check if the given value is a LDContextCommon.
 * @param kindOrContext
 * @returns true if it is an LDContextCommon
 *
 * Due to a limitation in the expressiveness of these highly polymorphic types any field
 * in a multi-kind context can either be a context or 'kind'. So we need to re-assure
 * the compiler that it isn't the word multi.
 *
 * Because we do not allow top level values in a multi-kind context we can validate
 * that as well.
 */
function isContextCommon(kindOrContext) {
    return kindOrContext && validators_1.TypeValidators.Object.is(kindOrContext);
}
/**
 * Validate a context kind.
 * @param kind
 * @returns true if the kind is valid.
 */
function validKind(kind) {
    return validators_1.TypeValidators.Kind.is(kind);
}
/**
 * Validate a context key.
 * @param key
 * @returns true if the key is valid.
 */
function validKey(key) {
    return validators_1.TypeValidators.String.is(key) && key !== '';
}
function processPrivateAttributes(privateAttributes, literals = false) {
    if (privateAttributes) {
        return privateAttributes.map((privateAttribute) => new AttributeReference_1.default(privateAttribute, literals));
    }
    return [];
}
function defined(value) {
    return value !== null && value !== undefined;
}
/**
 * Convert a legacy user to a single kind context.
 * @param user
 * @returns A single kind context.
 */
function legacyToSingleKind(user) {
    const singleKindContext = Object.assign(Object.assign({}, (user.custom || [])), { kind: 'user', key: String(user.key) });
    // For legacy users we never established a difference between null
    // and undefined for inputs. Because anonymous can be used in evaluations
    // we would want it to not possibly match true/false unless defined.
    // Which is different than coercing a null/undefined anonymous as `false`.
    if (defined(user.anonymous)) {
        const anonymous = !!user.anonymous;
        delete singleKindContext.anonymous;
        singleKindContext.anonymous = anonymous;
    }
    if (user.name !== null && user.name !== undefined) {
        singleKindContext.name = user.name;
    }
    if (user.ip !== null && user.ip !== undefined) {
        singleKindContext.ip = user.ip;
    }
    if (user.firstName !== null && user.firstName !== undefined) {
        singleKindContext.firstName = user.firstName;
    }
    if (user.lastName !== null && user.lastName !== undefined) {
        singleKindContext.lastName = user.lastName;
    }
    if (user.email !== null && user.email !== undefined) {
        singleKindContext.email = user.email;
    }
    if (user.avatar !== null && user.avatar !== undefined) {
        singleKindContext.avatar = user.avatar;
    }
    if (user.country !== null && user.country !== undefined) {
        singleKindContext.country = user.country;
    }
    // We are not pulling private attributes over because we will serialize
    // those from attribute references for events.
    return singleKindContext;
}
/**
 * Container for a context/contexts. Because contexts come from external code
 * they must be thoroughly validated and then formed to comply with
 * the type system.
 */
class Context {
    /**
     * Contexts should be created using the static factory method {@link Context.fromLDContext}.
     * @param kind The kind of the context.
     *
     * The factory methods are static functions within the class because they access private
     * implementation details, so they cannot be free functions.
     */
    constructor(valid, kind, message) {
        this.isMulti = false;
        this.isUser = false;
        this.wasLegacy = false;
        this.contexts = {};
        this.kind = kind;
        this.valid = valid;
        this.message = message;
    }
    static contextForError(kind, message) {
        return new Context(false, kind, message);
    }
    static getValueFromContext(reference, context) {
        if (!context || !reference.isValid) {
            return undefined;
        }
        if (reference.depth === 1 && reference.getComponent(0) === 'anonymous') {
            return !!(context === null || context === void 0 ? void 0 : context.anonymous);
        }
        return reference.get(context);
    }
    contextForKind(kind) {
        if (this.isMulti) {
            return this.contexts[kind];
        }
        if (this.kind === kind) {
            return this.context;
        }
        return undefined;
    }
    static fromMultiKindContext(context) {
        const kinds = Object.keys(context).filter((key) => key !== 'kind');
        const kindsValid = kinds.every(validKind);
        if (!kinds.length) {
            return Context.contextForError('multi', 'A multi-kind context must contain at least one kind');
        }
        if (!kindsValid) {
            return Context.contextForError('multi', 'Context contains invalid kinds');
        }
        const privateAttributes = {};
        let contextsAreObjects = true;
        const contexts = kinds.reduce((acc, kind) => {
            var _a;
            const singleContext = context[kind];
            if (isContextCommon(singleContext)) {
                acc[kind] = singleContext;
                privateAttributes[kind] = processPrivateAttributes((_a = singleContext._meta) === null || _a === void 0 ? void 0 : _a.privateAttributes);
            }
            else {
                // No early break isn't the most efficient, but it is an error condition.
                contextsAreObjects = false;
            }
            return acc;
        }, {});
        if (!contextsAreObjects) {
            return Context.contextForError('multi', 'Context contained contexts that were not objects');
        }
        if (!Object.values(contexts).every((part) => validKey(part.key))) {
            return Context.contextForError('multi', 'Context contained invalid keys');
        }
        // There was only a single kind in the multi-kind context.
        // So we can just translate this to a single-kind context.
        if (kinds.length === 1) {
            const kind = kinds[0];
            const created = new Context(true, kind);
            created.context = contexts[kind];
            created.privateAttributeReferences = privateAttributes;
            created.isUser = kind === 'user';
            return created;
        }
        const created = new Context(true, context.kind);
        created.contexts = contexts;
        created.privateAttributeReferences = privateAttributes;
        created.isMulti = true;
        return created;
    }
    static fromSingleKindContext(context) {
        var _a;
        const { key, kind } = context;
        const kindValid = validKind(kind);
        const keyValid = validKey(key);
        if (!kindValid) {
            return Context.contextForError(kind !== null && kind !== void 0 ? kind : 'unknown', 'The kind was not valid for the context');
        }
        if (!keyValid) {
            return Context.contextForError(kind, 'The key for the context was not valid');
        }
        // The JSON interfaces uses dangling _.
        // eslint-disable-next-line no-underscore-dangle
        const privateAttributeReferences = processPrivateAttributes((_a = context._meta) === null || _a === void 0 ? void 0 : _a.privateAttributes);
        const created = new Context(true, kind);
        created.isUser = kind === 'user';
        created.context = context;
        created.privateAttributeReferences = {
            [kind]: privateAttributeReferences,
        };
        return created;
    }
    static fromLegacyUser(context) {
        const keyValid = context.key !== undefined && context.key !== null;
        // For legacy users we allow empty keys.
        if (!keyValid) {
            return Context.contextForError('user', 'The key for the context was not valid');
        }
        const created = new Context(true, 'user');
        created.isUser = true;
        created.wasLegacy = true;
        created.context = legacyToSingleKind(context);
        created.privateAttributeReferences = {
            user: processPrivateAttributes(context.privateAttributeNames, true),
        };
        return created;
    }
    /**
     * Attempt to create a {@link Context} from an {@link LDContext}.
     * @param context The input context to create a Context from.
     * @returns a {@link Context}, if the context was not valid, then the returned contexts `valid`
     * property will be false.
     */
    static fromLDContext(context) {
        if (!context) {
            return Context.contextForError('unknown', 'No context specified. Returning default value');
        }
        if ((0, context_1.isSingleKind)(context)) {
            return Context.fromSingleKindContext(context);
        }
        if ((0, context_1.isMultiKind)(context)) {
            return Context.fromMultiKindContext(context);
        }
        if ((0, context_1.isLegacyUser)(context)) {
            return Context.fromLegacyUser(context);
        }
        return Context.contextForError('unknown', 'Context was not of a valid kind');
    }
    /**
     * Attempt to get a value for the given context kind using the given reference.
     * @param reference The reference to the value to get.
     * @param kind The kind of the context to get the value for.
     * @returns a value or `undefined` if one is not found.
     */
    valueForKind(reference, kind = DEFAULT_KIND) {
        if (reference.isKind) {
            return this.kinds;
        }
        return Context.getValueFromContext(reference, this.contextForKind(kind));
    }
    /**
     * Attempt to get a key for the specified kind.
     * @param kind The kind to get a key for.
     * @returns The key for the specified kind, or undefined.
     */
    key(kind = DEFAULT_KIND) {
        var _a;
        return (_a = this.contextForKind(kind)) === null || _a === void 0 ? void 0 : _a.key;
    }
    /**
     * True if this is a multi-kind context.
     */
    get isMultiKind() {
        return this.isMulti;
    }
    /**
     * Get the canonical key for this context.
     */
    get canonicalKey() {
        if (this.isUser) {
            return this.context.key;
        }
        if (this.isMulti) {
            return Object.keys(this.contexts)
                .sort()
                .map((key) => `${key}:${encodeKey(this.contexts[key].key)}`)
                .join(':');
        }
        return `${this.kind}:${encodeKey(this.context.key)}`;
    }
    /**
     * Get the kinds of this context.
     */
    get kinds() {
        if (this.isMulti) {
            return Object.keys(this.contexts);
        }
        return [this.kind];
    }
    /**
     * Get the kinds, and their keys, for this context.
     */
    get kindsAndKeys() {
        if (this.isMulti) {
            return Object.entries(this.contexts).reduce((acc, [kind, context]) => {
                acc[kind] = context.key;
                return acc;
            }, {});
        }
        return { [this.kind]: this.context.key };
    }
    /**
     * Get the attribute references.
     *
     * @param kind
     */
    privateAttributes(kind) {
        var _a;
        return ((_a = this.privateAttributeReferences) === null || _a === void 0 ? void 0 : _a[kind]) || [];
    }
    /**
     * Get the underlying context objects from this context.
     *
     * This method is intended to be used in event generation.
     *
     * The returned objects should not be modified.
     */
    getContexts() {
        if (this.isMulti) {
            return Object.entries(this.contexts);
        }
        return [[this.kind, this.context]];
    }
    get legacy() {
        return this.wasLegacy;
    }
}
Context.userKind = DEFAULT_KIND;
exports.default = Context;
//# sourceMappingURL=Context.js.map