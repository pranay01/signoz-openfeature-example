"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable class-methods-use-this */
const js_sdk_common_1 = require("@launchdarkly/js-sdk-common");
const api_1 = require("./api");
const BigSegmentsManager_1 = require("./BigSegmentsManager");
const createStreamListeners_1 = require("./data_sources/createStreamListeners");
const DataSourceUpdates_1 = require("./data_sources/DataSourceUpdates");
const PollingProcessor_1 = require("./data_sources/PollingProcessor");
const Requestor_1 = require("./data_sources/Requestor");
const createDiagnosticsInitConfig_1 = require("./diagnostics/createDiagnosticsInitConfig");
const collection_1 = require("./evaluation/collection");
const EvalResult_1 = require("./evaluation/EvalResult");
const Evaluator_1 = require("./evaluation/Evaluator");
const ContextDeduplicator_1 = require("./events/ContextDeduplicator");
const EventFactory_1 = require("./events/EventFactory");
const isExperiment_1 = require("./events/isExperiment");
const FlagsStateBuilder_1 = require("./FlagsStateBuilder");
const HookRunner_1 = require("./hooks/HookRunner");
const MigrationOpEventConversion_1 = require("./MigrationOpEventConversion");
const MigrationOpTracker_1 = require("./MigrationOpTracker");
const Configuration_1 = require("./options/Configuration");
const VersionedDataKinds_1 = require("./store/VersionedDataKinds");
const { ClientMessages, ErrorKinds, NullEventProcessor } = js_sdk_common_1.internal;
var InitState;
(function (InitState) {
    InitState[InitState["Initializing"] = 0] = "Initializing";
    InitState[InitState["Initialized"] = 1] = "Initialized";
    InitState[InitState["Failed"] = 2] = "Failed";
})(InitState || (InitState = {}));
const HIGH_TIMEOUT_THRESHOLD = 60;
const BOOL_VARIATION_METHOD_NAME = 'LDClient.boolVariation';
const NUMBER_VARIATION_METHOD_NAME = 'LDClient.numberVariation';
const STRING_VARIATION_METHOD_NAME = 'LDClient.stringVariation';
const JSON_VARIATION_METHOD_NAME = 'LDClient.jsonVariation';
const VARIATION_METHOD_NAME = 'LDClient.variation';
const MIGRATION_VARIATION_METHOD_NAME = 'LDClient.migrationVariation';
const BOOL_VARIATION_DETAIL_METHOD_NAME = 'LDClient.boolVariationDetail';
const NUMBER_VARIATION_DETAIL_METHOD_NAME = 'LDClient.numberVariationDetail';
const STRING_VARIATION_DETAIL_METHOD_NAME = 'LDClient.stringVariationDetail';
const JSON_VARIATION_DETAIL_METHOD_NAME = 'LDClient.jsonVariationDetail';
const VARIATION_METHOD_DETAIL_NAME = 'LDClient.variationDetail';
/**
 * @ignore
 */
class LDClientImpl {
    constructor(sdkKey, platform, options, callbacks, internalOptions) {
        var _a, _b, _c, _d, _e;
        this.sdkKey = sdkKey;
        this.platform = platform;
        this.initState = InitState.Initializing;
        this.eventFactoryDefault = new EventFactory_1.default(false);
        this.eventFactoryWithReasons = new EventFactory_1.default(true);
        this.onError = callbacks.onError;
        this.onFailed = callbacks.onFailed;
        this.onReady = callbacks.onReady;
        const { onUpdate, hasEventListeners } = callbacks;
        const config = new Configuration_1.default(options, internalOptions);
        this.hookRunner = new HookRunner_1.default(config.logger, config.hooks || []);
        if (!sdkKey && !config.offline) {
            throw new Error('You must configure the client with an SDK key');
        }
        this.config = config;
        this.logger = config.logger;
        const clientContext = new js_sdk_common_1.ClientContext(sdkKey, config, platform);
        const featureStore = config.featureStoreFactory(clientContext);
        const dataSourceUpdates = new DataSourceUpdates_1.default(featureStore, hasEventListeners, onUpdate);
        if (config.sendEvents && !config.offline && !config.diagnosticOptOut) {
            this.diagnosticsManager = new js_sdk_common_1.internal.DiagnosticsManager(sdkKey, platform, (0, createDiagnosticsInitConfig_1.default)(config, platform, featureStore));
        }
        if (!config.sendEvents || config.offline) {
            this.eventProcessor = new NullEventProcessor();
        }
        else {
            this.eventProcessor = new js_sdk_common_1.internal.EventProcessor(config, clientContext, new ContextDeduplicator_1.default(config), this.diagnosticsManager);
        }
        this.featureStore = featureStore;
        const manager = new BigSegmentsManager_1.default((_b = (_a = config.bigSegments) === null || _a === void 0 ? void 0 : _a.store) === null || _b === void 0 ? void 0 : _b.call(_a, clientContext), (_c = config.bigSegments) !== null && _c !== void 0 ? _c : {}, config.logger, this.platform.crypto);
        this.bigSegmentsManager = manager;
        this.bigSegmentStatusProviderInternal = manager.statusProvider;
        const queries = {
            getFlag(key, cb) {
                featureStore.get(VersionedDataKinds_1.default.Features, key, (item) => cb(item));
            },
            getSegment(key, cb) {
                featureStore.get(VersionedDataKinds_1.default.Segments, key, (item) => cb(item));
            },
            getBigSegmentsMembership(userKey) {
                return manager.getUserMembership(userKey);
            },
        };
        this.evaluator = new Evaluator_1.default(this.platform, queries);
        const listeners = (0, createStreamListeners_1.createStreamListeners)(dataSourceUpdates, this.logger, {
            put: () => this.initSuccess(),
        });
        const makeDefaultProcessor = () => config.stream
            ? new js_sdk_common_1.internal.StreamingProcessor(sdkKey, clientContext, '/all', listeners, this.diagnosticsManager, (e) => this.dataSourceErrorHandler(e), this.config.streamInitialReconnectDelay)
            : new PollingProcessor_1.default(config, new Requestor_1.default(sdkKey, config, this.platform.info, this.platform.requests), dataSourceUpdates, () => this.initSuccess(), (e) => this.dataSourceErrorHandler(e));
        if (!(config.offline || config.useLdd)) {
            this.updateProcessor =
                (_e = (_d = config.updateProcessorFactory) === null || _d === void 0 ? void 0 : _d.call(config, clientContext, dataSourceUpdates, () => this.initSuccess(), (e) => this.dataSourceErrorHandler(e))) !== null && _e !== void 0 ? _e : makeDefaultProcessor();
        }
        if (this.updateProcessor) {
            this.updateProcessor.start();
        }
        else {
            // Deferring the start callback should allow client construction to complete before we start
            // emitting events. Allowing the client an opportunity to register events.
            setTimeout(() => this.initSuccess(), 0);
        }
    }
    initialized() {
        return this.initState === InitState.Initialized;
    }
    waitForInitialization(options) {
        // An initialization promise is only created if someone is going to use that promise.
        // If we always created an initialization promise, and there was no call waitForInitialization
        // by the time the promise was rejected, then that would result in an unhandled promise
        // rejection.
        var _a, _b;
        // If there is no update processor, then there is functionally no initialization
        // so it is fine not to wait.
        if ((options === null || options === void 0 ? void 0 : options.timeout) === undefined && this.updateProcessor !== undefined) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn('The waitForInitialization function was called without a timeout specified.' +
                ' In a future version a default timeout will be applied.');
        }
        if ((options === null || options === void 0 ? void 0 : options.timeout) !== undefined &&
            (options === null || options === void 0 ? void 0 : options.timeout) > HIGH_TIMEOUT_THRESHOLD &&
            this.updateProcessor !== undefined) {
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.warn('The waitForInitialization function was called with a timeout greater than ' +
                `${HIGH_TIMEOUT_THRESHOLD} seconds. We recommend a timeout of less than ` +
                `${HIGH_TIMEOUT_THRESHOLD} seconds.`);
        }
        // Initialization promise was created by a previous call to waitForInitialization.
        if (this.initializedPromise) {
            // This promise may already be resolved/rejected, but it doesn't hurt to wrap it in a timeout.
            return this.clientWithTimeout(this.initializedPromise, options === null || options === void 0 ? void 0 : options.timeout, this.logger);
        }
        // Initialization completed before waitForInitialization was called, so we have completed
        // and there was no promise. So we make a resolved promise and return it.
        if (this.initState === InitState.Initialized) {
            this.initializedPromise = Promise.resolve(this);
            // Already initialized, no need to timeout.
            return this.initializedPromise;
        }
        // Initialization failed before waitForInitialization was called, so we have completed
        // and there was no promise. So we make a rejected promise and return it.
        if (this.initState === InitState.Failed) {
            // Already failed, no need to timeout.
            this.initializedPromise = Promise.reject(this.rejectionReason);
            return this.initializedPromise;
        }
        if (!this.initializedPromise) {
            this.initializedPromise = new Promise((resolve, reject) => {
                this.initResolve = resolve;
                this.initReject = reject;
            });
        }
        return this.clientWithTimeout(this.initializedPromise, options === null || options === void 0 ? void 0 : options.timeout, this.logger);
    }
    variation(key, context, defaultValue, callback) {
        return this.hookRunner
            .withEvaluationSeries(key, context, defaultValue, VARIATION_METHOD_NAME, () => new Promise((resolve) => {
            this.evaluateIfPossible(key, context, defaultValue, this.eventFactoryDefault, (res) => {
                resolve(res.detail);
            });
        }))
            .then((detail) => {
            callback === null || callback === void 0 ? void 0 : callback(null, detail.value);
            return detail.value;
        });
    }
    variationDetail(key, context, defaultValue, callback) {
        return this.hookRunner.withEvaluationSeries(key, context, defaultValue, VARIATION_METHOD_DETAIL_NAME, () => new Promise((resolve) => {
            this.evaluateIfPossible(key, context, defaultValue, this.eventFactoryWithReasons, (res) => {
                resolve(res.detail);
                callback === null || callback === void 0 ? void 0 : callback(null, res.detail);
            });
        }));
    }
    typedEval(key, context, defaultValue, eventFactory, methodName, typeChecker) {
        return this.hookRunner.withEvaluationSeries(key, context, defaultValue, methodName, () => new Promise((resolve) => {
            this.evaluateIfPossible(key, context, defaultValue, eventFactory, (res) => {
                const typedRes = {
                    value: res.detail.value,
                    reason: res.detail.reason,
                    variationIndex: res.detail.variationIndex,
                };
                resolve(typedRes);
            }, typeChecker);
        }));
    }
    async boolVariation(key, context, defaultValue) {
        return (await this.typedEval(key, context, defaultValue, this.eventFactoryDefault, BOOL_VARIATION_METHOD_NAME, (value) => [js_sdk_common_1.TypeValidators.Boolean.is(value), js_sdk_common_1.TypeValidators.Boolean.getType()])).value;
    }
    async numberVariation(key, context, defaultValue) {
        return (await this.typedEval(key, context, defaultValue, this.eventFactoryDefault, NUMBER_VARIATION_METHOD_NAME, (value) => [js_sdk_common_1.TypeValidators.Number.is(value), js_sdk_common_1.TypeValidators.Number.getType()])).value;
    }
    async stringVariation(key, context, defaultValue) {
        return (await this.typedEval(key, context, defaultValue, this.eventFactoryDefault, STRING_VARIATION_METHOD_NAME, (value) => [js_sdk_common_1.TypeValidators.String.is(value), js_sdk_common_1.TypeValidators.String.getType()])).value;
    }
    jsonVariation(key, context, defaultValue) {
        return this.hookRunner
            .withEvaluationSeries(key, context, defaultValue, JSON_VARIATION_METHOD_NAME, () => new Promise((resolve) => {
            this.evaluateIfPossible(key, context, defaultValue, this.eventFactoryDefault, (res) => {
                resolve(res.detail);
            });
        }))
            .then((detail) => detail.value);
    }
    boolVariationDetail(key, context, defaultValue) {
        return this.typedEval(key, context, defaultValue, this.eventFactoryWithReasons, BOOL_VARIATION_DETAIL_METHOD_NAME, (value) => [js_sdk_common_1.TypeValidators.Boolean.is(value), js_sdk_common_1.TypeValidators.Boolean.getType()]);
    }
    numberVariationDetail(key, context, defaultValue) {
        return this.typedEval(key, context, defaultValue, this.eventFactoryWithReasons, NUMBER_VARIATION_DETAIL_METHOD_NAME, (value) => [js_sdk_common_1.TypeValidators.Number.is(value), js_sdk_common_1.TypeValidators.Number.getType()]);
    }
    stringVariationDetail(key, context, defaultValue) {
        return this.typedEval(key, context, defaultValue, this.eventFactoryWithReasons, STRING_VARIATION_DETAIL_METHOD_NAME, (value) => [js_sdk_common_1.TypeValidators.String.is(value), js_sdk_common_1.TypeValidators.String.getType()]);
    }
    jsonVariationDetail(key, context, defaultValue) {
        return this.hookRunner.withEvaluationSeries(key, context, defaultValue, JSON_VARIATION_DETAIL_METHOD_NAME, () => new Promise((resolve) => {
            this.evaluateIfPossible(key, context, defaultValue, this.eventFactoryWithReasons, (res) => {
                resolve(res.detail);
            });
        }));
    }
    async migrationVariationInternal(key, context, defaultValue) {
        var _a;
        const convertedContext = js_sdk_common_1.Context.fromLDContext(context);
        const res = await new Promise((resolve) => {
            this.evaluateIfPossible(key, context, defaultValue, this.eventFactoryWithReasons, ({ detail }, flag) => {
                if (!(0, api_1.IsMigrationStage)(detail.value)) {
                    const error = new Error(`Unrecognized MigrationState for "${key}"; returning default value.`);
                    this.onError(error);
                    const reason = {
                        kind: 'ERROR',
                        errorKind: ErrorKinds.WrongType,
                    };
                    resolve({
                        detail: {
                            value: defaultValue,
                            reason,
                        },
                        flag,
                    });
                    return;
                }
                resolve({ detail, flag });
            });
        });
        const { detail, flag } = res;
        const contextKeys = convertedContext.valid ? convertedContext.kindsAndKeys : {};
        const checkRatio = (_a = flag === null || flag === void 0 ? void 0 : flag.migration) === null || _a === void 0 ? void 0 : _a.checkRatio;
        const samplingRatio = flag === null || flag === void 0 ? void 0 : flag.samplingRatio;
        return {
            detail,
            migration: {
                value: detail.value,
                tracker: new MigrationOpTracker_1.default(key, contextKeys, defaultValue, detail.value, detail.reason, checkRatio, 
                // Can be null for compatibility reasons.
                detail.variationIndex === null ? undefined : detail.variationIndex, flag === null || flag === void 0 ? void 0 : flag.version, samplingRatio, this.logger),
            },
        };
    }
    async migrationVariation(key, context, defaultValue) {
        const res = await this.hookRunner.withEvaluationSeriesExtraDetail(key, context, defaultValue, MIGRATION_VARIATION_METHOD_NAME, () => this.migrationVariationInternal(key, context, defaultValue));
        return res.migration;
    }
    allFlagsState(context, options, callback) {
        var _a, _b, _c;
        if (this.config.offline) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info('allFlagsState() called in offline mode. Returning empty state.');
            const allFlagState = new FlagsStateBuilder_1.default(false, false).build();
            callback === null || callback === void 0 ? void 0 : callback(null, allFlagState);
            return Promise.resolve(allFlagState);
        }
        const evalContext = js_sdk_common_1.Context.fromLDContext(context);
        if (!evalContext.valid) {
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.info(`${(_c = evalContext.message) !== null && _c !== void 0 ? _c : 'Invalid context.'}. Returning empty state.`);
            return Promise.resolve(new FlagsStateBuilder_1.default(false, false).build());
        }
        return new Promise((resolve) => {
            const doEval = (valid) => this.featureStore.all(VersionedDataKinds_1.default.Features, (allFlags) => {
                const builder = new FlagsStateBuilder_1.default(valid, !!(options === null || options === void 0 ? void 0 : options.withReasons));
                const clientOnly = !!(options === null || options === void 0 ? void 0 : options.clientSideOnly);
                const detailsOnlyIfTracked = !!(options === null || options === void 0 ? void 0 : options.detailsOnlyForTrackedFlags);
                (0, collection_1.allAsync)(Object.values(allFlags), (storeItem, iterCb) => {
                    var _a;
                    const flag = storeItem;
                    if (clientOnly && !((_a = flag.clientSideAvailability) === null || _a === void 0 ? void 0 : _a.usingEnvironmentId)) {
                        iterCb(true);
                        return;
                    }
                    this.evaluator.evaluateCb(flag, evalContext, (res) => {
                        var _a;
                        if (res.isError) {
                            this.onError(new Error(`Error for feature flag "${flag.key}" while evaluating all flags: ${res.message}`));
                        }
                        const requireExperimentData = (0, isExperiment_1.default)(flag, res.detail.reason);
                        builder.addFlag(flag, res.detail.value, (_a = res.detail.variationIndex) !== null && _a !== void 0 ? _a : undefined, res.detail.reason, flag.trackEvents || requireExperimentData, requireExperimentData, detailsOnlyIfTracked);
                        iterCb(true);
                    });
                }, () => {
                    const res = builder.build();
                    callback === null || callback === void 0 ? void 0 : callback(null, res);
                    resolve(res);
                });
            });
            if (!this.initialized()) {
                this.featureStore.initialized((storeInitialized) => {
                    var _a, _b;
                    let valid = true;
                    if (storeInitialized) {
                        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn('Called allFlagsState before client initialization; using last known' +
                            ' values from data store');
                    }
                    else {
                        (_b = this.logger) === null || _b === void 0 ? void 0 : _b.warn('Called allFlagsState before client initialization. Data store not available; ' +
                            'returning empty state');
                        valid = false;
                    }
                    doEval(valid);
                });
            }
            else {
                doEval(true);
            }
        });
    }
    secureModeHash(context) {
        const checkedContext = js_sdk_common_1.Context.fromLDContext(context);
        const key = checkedContext.valid ? checkedContext.canonicalKey : undefined;
        const hmac = this.platform.crypto.createHmac('sha256', this.sdkKey);
        if (key === undefined) {
            throw new js_sdk_common_1.LDClientError('Could not generate secure mode hash for invalid context');
        }
        hmac.update(key);
        return hmac.digest('hex');
    }
    close() {
        var _a;
        this.eventProcessor.close();
        (_a = this.updateProcessor) === null || _a === void 0 ? void 0 : _a.close();
        this.featureStore.close();
        this.bigSegmentsManager.close();
    }
    isOffline() {
        return this.config.offline;
    }
    track(key, context, data, metricValue) {
        var _a, _b;
        const checkedContext = js_sdk_common_1.Context.fromLDContext(context);
        if (!checkedContext.valid) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn(ClientMessages.missingContextKeyNoEvent);
            return;
        }
        // 0 is valid, so do not truthy check the metric value
        if (metricValue !== undefined && !js_sdk_common_1.TypeValidators.Number.is(metricValue)) {
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.warn(ClientMessages.invalidMetricValue(typeof metricValue));
        }
        this.eventProcessor.sendEvent(this.eventFactoryDefault.customEvent(key, checkedContext, data, metricValue));
    }
    trackMigration(event) {
        const converted = (0, MigrationOpEventConversion_1.default)(event);
        if (!converted) {
            return;
        }
        this.eventProcessor.sendEvent(converted);
    }
    identify(context) {
        var _a;
        const checkedContext = js_sdk_common_1.Context.fromLDContext(context);
        if (!checkedContext.valid) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn(ClientMessages.missingContextKeyNoEvent);
            return;
        }
        this.eventProcessor.sendEvent(this.eventFactoryDefault.identifyEvent(checkedContext));
    }
    async flush(callback) {
        try {
            await this.eventProcessor.flush();
        }
        catch (err) {
            callback === null || callback === void 0 ? void 0 : callback(err, false);
        }
        callback === null || callback === void 0 ? void 0 : callback(null, true);
    }
    addHook(hook) {
        this.hookRunner.addHook(hook);
    }
    variationInternal(flagKey, context, defaultValue, eventFactory, cb, typeChecker) {
        var _a, _b;
        if (this.config.offline) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info('Variation called in offline mode. Returning default value.');
            cb(EvalResult_1.default.forError(ErrorKinds.ClientNotReady, undefined, defaultValue));
            return;
        }
        const evalContext = js_sdk_common_1.Context.fromLDContext(context);
        if (!evalContext.valid) {
            this.onError(new js_sdk_common_1.LDClientError(`${(_b = evalContext.message) !== null && _b !== void 0 ? _b : 'Context not valid;'} returning default value.`));
            cb(EvalResult_1.default.forError(ErrorKinds.UserNotSpecified, undefined, defaultValue));
            return;
        }
        this.featureStore.get(VersionedDataKinds_1.default.Features, flagKey, (item) => {
            const flag = item;
            if (!flag) {
                const error = new js_sdk_common_1.LDClientError(`Unknown feature flag "${flagKey}"; returning default value`);
                this.onError(error);
                const result = EvalResult_1.default.forError(ErrorKinds.FlagNotFound, undefined, defaultValue);
                this.eventProcessor.sendEvent(this.eventFactoryDefault.unknownFlagEvent(flagKey, defaultValue, evalContext));
                cb(result);
                return;
            }
            this.evaluator.evaluateCb(flag, evalContext, (evalRes) => {
                var _a;
                if (evalRes.detail.variationIndex === undefined ||
                    evalRes.detail.variationIndex === null) {
                    (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug('Result value is null in variation');
                    evalRes.setDefault(defaultValue);
                }
                if (typeChecker) {
                    const [matched, type] = typeChecker(evalRes.detail.value);
                    if (!matched) {
                        const errorRes = EvalResult_1.default.forError(ErrorKinds.WrongType, `Did not receive expected type (${type}) evaluating feature flag "${flagKey}"`, defaultValue);
                        this.sendEvalEvent(errorRes, eventFactory, flag, evalContext, defaultValue);
                        cb(errorRes, flag);
                        return;
                    }
                }
                this.sendEvalEvent(evalRes, eventFactory, flag, evalContext, defaultValue);
                cb(evalRes, flag);
            }, eventFactory);
        });
    }
    sendEvalEvent(evalRes, eventFactory, flag, evalContext, defaultValue) {
        var _a;
        (_a = evalRes.events) === null || _a === void 0 ? void 0 : _a.forEach((event) => {
            this.eventProcessor.sendEvent(Object.assign({}, event));
        });
        this.eventProcessor.sendEvent(eventFactory.evalEventServer(flag, evalContext, evalRes.detail, defaultValue, undefined));
    }
    evaluateIfPossible(flagKey, context, defaultValue, eventFactory, cb, typeChecker) {
        if (!this.initialized()) {
            this.featureStore.initialized((storeInitialized) => {
                var _a, _b;
                if (storeInitialized) {
                    (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn('Variation called before LaunchDarkly client initialization completed' +
                        " (did you wait for the 'ready' event?) - using last known values from feature store");
                    this.variationInternal(flagKey, context, defaultValue, eventFactory, cb, typeChecker);
                    return;
                }
                (_b = this.logger) === null || _b === void 0 ? void 0 : _b.warn('Variation called before LaunchDarkly client initialization completed (did you wait for the' +
                    "'ready' event?) - using default value");
                cb(EvalResult_1.default.forError(ErrorKinds.ClientNotReady, undefined, defaultValue));
            });
            return;
        }
        this.variationInternal(flagKey, context, defaultValue, eventFactory, cb, typeChecker);
    }
    dataSourceErrorHandler(e) {
        var _a;
        const error = e.code === 401 ? new Error('Authentication failed. Double check your SDK key.') : e;
        this.onError(error);
        this.onFailed(error);
        if (!this.initialized()) {
            this.initState = InitState.Failed;
            this.rejectionReason = error;
            (_a = this.initReject) === null || _a === void 0 ? void 0 : _a.call(this, error);
        }
    }
    initSuccess() {
        var _a;
        if (!this.initialized()) {
            this.initState = InitState.Initialized;
            (_a = this.initResolve) === null || _a === void 0 ? void 0 : _a.call(this, this);
            this.onReady();
        }
    }
    /**
     * Apply a timeout promise to a base promise. This is for use with waitForInitialization.
     * Currently it returns a LDClient. In the future it should return a status.
     *
     * The client isn't always the expected type of the consumer. It returns an LDClient interface
     * which is less capable than, for example, the node client interface.
     *
     * @param basePromise The promise to race against a timeout.
     * @param timeout The timeout in seconds.
     * @param logger A logger to log when the timeout expires.
     * @returns
     */
    clientWithTimeout(basePromise, timeout, logger) {
        if (timeout) {
            const cancelableTimeout = (0, js_sdk_common_1.cancelableTimedPromise)(timeout, 'waitForInitialization');
            return Promise.race([
                basePromise.then(() => cancelableTimeout.cancel()).then(() => this),
                cancelableTimeout.promise.then(() => this),
            ]).catch((reason) => {
                if (reason instanceof js_sdk_common_1.LDTimeoutError) {
                    logger === null || logger === void 0 ? void 0 : logger.error(reason.message);
                }
                throw reason;
            });
        }
        return basePromise;
    }
}
exports.default = LDClientImpl;
//# sourceMappingURL=LDClientImpl.js.map