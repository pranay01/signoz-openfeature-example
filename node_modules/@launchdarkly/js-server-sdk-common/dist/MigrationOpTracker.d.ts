import { LDEvaluationReason, LDLogger } from '@launchdarkly/js-sdk-common';
import { LDMigrationStage, LDMigrationTracker } from './api';
import { LDMigrationOp, LDMigrationOpEvent } from './api/data';
import { LDMigrationOrigin } from './api/LDMigration';
export default class MigrationOpTracker implements LDMigrationTracker {
    private readonly flagKey;
    private readonly contextKeys;
    private readonly defaultStage;
    private readonly stage;
    private readonly reason;
    private readonly checkRatio?;
    private readonly variation?;
    private readonly version?;
    private readonly samplingRatio?;
    private readonly logger?;
    private errors;
    private wasInvoked;
    private consistencyCheck;
    private latencyMeasurement;
    private operation?;
    constructor(flagKey: string, contextKeys: Record<string, string>, defaultStage: LDMigrationStage, stage: LDMigrationStage, reason: LDEvaluationReason, checkRatio?: number | undefined, variation?: number | undefined, version?: number | undefined, samplingRatio?: number | undefined, logger?: LDLogger | undefined);
    op(op: LDMigrationOp): void;
    error(origin: LDMigrationOrigin): void;
    consistency(check: () => boolean): void;
    latency(origin: LDMigrationOrigin, value: number): void;
    invoked(origin: LDMigrationOrigin): void;
    createEvent(): LDMigrationOpEvent | undefined;
    private logTag;
    private latencyConsistencyMessage;
    private errorConsistencyMessage;
    private consistencyCheckConsistencyMessage;
    private checkOriginEventConsistency;
    /**
     * Check that the latency, error, consistency and invoked measurements are self-consistent.
     */
    private measurementConsistencyCheck;
    private populateInvoked;
    private populateConsistency;
    private populateErrors;
    private populateLatency;
}
//# sourceMappingURL=MigrationOpTracker.d.ts.map