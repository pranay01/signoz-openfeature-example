import { internal, LDContext, LDEvaluationDetail, LDEvaluationDetailTyped, Platform } from '@launchdarkly/js-sdk-common';
import { LDClient, LDFlagsState, LDFlagsStateOptions, LDMigrationOpEvent, LDMigrationStage, LDMigrationVariation, LDOptions } from './api';
import { Hook } from './api/integrations/Hook';
import { LDWaitForInitializationOptions } from './api/LDWaitForInitializationOptions';
import BigSegmentStoreStatusProvider from './BigSegmentStatusProviderImpl';
export interface LDClientCallbacks {
    onError: (err: Error) => void;
    onFailed: (err: Error) => void;
    onReady: () => void;
    onUpdate: (key: string) => void;
    hasEventListeners: () => boolean;
}
/**
 * @ignore
 */
export default class LDClientImpl implements LDClient {
    private sdkKey;
    private platform;
    private initState;
    private featureStore;
    private updateProcessor?;
    private eventFactoryDefault;
    private eventFactoryWithReasons;
    private eventProcessor;
    private evaluator;
    private initResolve?;
    private initReject?;
    private rejectionReason;
    private initializedPromise?;
    private logger?;
    private config;
    private bigSegmentsManager;
    private onError;
    private onFailed;
    private onReady;
    private diagnosticsManager?;
    private hookRunner;
    /**
     * Intended for use by platform specific client implementations.
     *
     * It is not included in the main interface because it requires the use of
     * a platform event system. For node this would be an EventEmitter, for other
     * platforms it would likely be an EventTarget.
     */
    protected bigSegmentStatusProviderInternal: BigSegmentStoreStatusProvider;
    constructor(sdkKey: string, platform: Platform, options: LDOptions, callbacks: LDClientCallbacks, internalOptions?: internal.LDInternalOptions);
    initialized(): boolean;
    waitForInitialization(options?: LDWaitForInitializationOptions): Promise<LDClient>;
    variation(key: string, context: LDContext, defaultValue: any, callback?: (err: any, res: any) => void): Promise<any>;
    variationDetail(key: string, context: LDContext, defaultValue: any, callback?: (err: any, res: LDEvaluationDetail) => void): Promise<LDEvaluationDetail>;
    private typedEval;
    boolVariation(key: string, context: LDContext, defaultValue: boolean): Promise<boolean>;
    numberVariation(key: string, context: LDContext, defaultValue: number): Promise<number>;
    stringVariation(key: string, context: LDContext, defaultValue: string): Promise<string>;
    jsonVariation(key: string, context: LDContext, defaultValue: unknown): Promise<unknown>;
    boolVariationDetail(key: string, context: LDContext, defaultValue: boolean): Promise<LDEvaluationDetailTyped<boolean>>;
    numberVariationDetail(key: string, context: LDContext, defaultValue: number): Promise<LDEvaluationDetailTyped<number>>;
    stringVariationDetail(key: string, context: LDContext, defaultValue: string): Promise<LDEvaluationDetailTyped<string>>;
    jsonVariationDetail(key: string, context: LDContext, defaultValue: unknown): Promise<LDEvaluationDetailTyped<unknown>>;
    private migrationVariationInternal;
    migrationVariation(key: string, context: LDContext, defaultValue: LDMigrationStage): Promise<LDMigrationVariation>;
    allFlagsState(context: LDContext, options?: LDFlagsStateOptions, callback?: (err: Error | null, res: LDFlagsState) => void): Promise<LDFlagsState>;
    secureModeHash(context: LDContext): string;
    close(): void;
    isOffline(): boolean;
    track(key: string, context: LDContext, data?: any, metricValue?: number): void;
    trackMigration(event: LDMigrationOpEvent): void;
    identify(context: LDContext): void;
    flush(callback?: (err: Error | null, res: boolean) => void): Promise<void>;
    addHook(hook: Hook): void;
    private variationInternal;
    private sendEvalEvent;
    private evaluateIfPossible;
    private dataSourceErrorHandler;
    private initSuccess;
    /**
     * Apply a timeout promise to a base promise. This is for use with waitForInitialization.
     * Currently it returns a LDClient. In the future it should return a status.
     *
     * The client isn't always the expected type of the consumer. It returns an LDClient interface
     * which is less capable than, for example, the node client interface.
     *
     * @param basePromise The promise to race against a timeout.
     * @param timeout The timeout in seconds.
     * @param logger A logger to log when the timeout expires.
     * @returns
     */
    private clientWithTimeout;
}
//# sourceMappingURL=LDClientImpl.d.ts.map