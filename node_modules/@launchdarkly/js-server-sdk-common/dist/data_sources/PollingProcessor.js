"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const js_sdk_common_1 = require("@launchdarkly/js-sdk-common");
const store_1 = require("../store");
const VersionedDataKinds_1 = require("../store/VersionedDataKinds");
/**
 * @internal
 */
class PollingProcessor {
    constructor(config, requestor, featureStore, initSuccessHandler = () => { }, errorHandler) {
        this.requestor = requestor;
        this.featureStore = featureStore;
        this.initSuccessHandler = initSuccessHandler;
        this.errorHandler = errorHandler;
        this.stopped = false;
        this.logger = config.logger;
        this.pollInterval = config.pollInterval;
    }
    poll() {
        var _a;
        if (this.stopped) {
            return;
        }
        const reportJsonError = (data) => {
            var _a, _b, _c;
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error('Polling received invalid data');
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug(`Invalid JSON follows: ${data}`);
            (_c = this.errorHandler) === null || _c === void 0 ? void 0 : _c.call(this, new js_sdk_common_1.LDPollingError('Malformed JSON data in polling response'));
        };
        const startTime = Date.now();
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug('Polling LaunchDarkly for feature flag updates');
        this.requestor.requestAllData((err, body) => {
            var _a, _b, _c, _d;
            const elapsed = Date.now() - startTime;
            const sleepFor = Math.max(this.pollInterval * 1000 - elapsed, 0);
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug('Elapsed: %d ms, sleeping for %d ms', elapsed, sleepFor);
            if (err) {
                const { status } = err;
                if (status && !(0, js_sdk_common_1.isHttpRecoverable)(status)) {
                    const message = (0, js_sdk_common_1.httpErrorMessage)(err, 'polling request');
                    (_b = this.logger) === null || _b === void 0 ? void 0 : _b.error(message);
                    (_c = this.errorHandler) === null || _c === void 0 ? void 0 : _c.call(this, new js_sdk_common_1.LDPollingError(message, status));
                    // It is not recoverable, return and do not trigger another
                    // poll.
                    return;
                }
                (_d = this.logger) === null || _d === void 0 ? void 0 : _d.warn((0, js_sdk_common_1.httpErrorMessage)(err, 'polling request', 'will retry'));
            }
            else if (body) {
                const parsed = (0, store_1.deserializePoll)(body);
                if (!parsed) {
                    // We could not parse this JSON. Report the problem and fallthrough to
                    // start another poll.
                    reportJsonError(body);
                }
                else {
                    const initData = {
                        [VersionedDataKinds_1.default.Features.namespace]: parsed.flags,
                        [VersionedDataKinds_1.default.Segments.namespace]: parsed.segments,
                    };
                    this.featureStore.init(initData, () => {
                        this.initSuccessHandler();
                        // Triggering the next poll after the init has completed.
                        this.timeoutHandle = setTimeout(() => {
                            this.poll();
                        }, sleepFor);
                    });
                    // The poll will be triggered by  the feature store initialization
                    // completing.
                    return;
                }
            }
            // Falling through, there was some type of error and we need to trigger
            // a new poll.
            this.timeoutHandle = setTimeout(() => {
                this.poll();
            }, sleepFor);
        });
    }
    start() {
        this.poll();
    }
    stop() {
        if (this.timeoutHandle) {
            clearTimeout(this.timeoutHandle);
            this.timeoutHandle = undefined;
        }
        this.stopped = true;
    }
    close() {
        this.stop();
    }
}
exports.default = PollingProcessor;
//# sourceMappingURL=PollingProcessor.js.map