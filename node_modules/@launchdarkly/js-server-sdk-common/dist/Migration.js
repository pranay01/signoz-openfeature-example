"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMigration = exports.LDMigrationError = exports.LDMigrationSuccess = void 0;
const api_1 = require("./api");
const LDMigrationOptions_1 = require("./api/options/LDMigrationOptions");
async function safeCall(method) {
    try {
        // Awaiting to allow catching.
        const res = await method();
        return res;
    }
    catch (error) {
        return {
            success: false,
            error,
        };
    }
}
/**
 * Report a successful migration operation from `readNew`, `readOld`, `writeNew` or `writeOld`.
 *
 * ```
 * readNew: async () => {
 *   const myResult = doMyOldRead();
 *   if(myResult.wasGood) {
 *     return LDMigrationSuccess(myResult);
 *   }
 *   return LDMigrationError(myResult.error)
 * }
 * ```
 *
 * @param result The result of the operation.
 * @returns An {@link LDMethodResult}
 */
function LDMigrationSuccess(result) {
    return {
        success: true,
        result,
    };
}
exports.LDMigrationSuccess = LDMigrationSuccess;
/**
 * Report a failed migration operation from `readNew`, `readOld`, `writeNew` or `writeOld`.
 *
 * ```
 * readNew: async () => {
 *   const myResult = doMyOldRead();
 *   if(myResult.wasGood) {
 *     return LDMigrationSuccess(myResult);
 *   }
 *   return LDMigrationError(myResult.error)
 * }
 * ```
 *
 * @param result The result of the operations.
 * @returns An {@link LDMethodResult}
 */
function LDMigrationError(error) {
    return {
        success: false,
        error,
    };
}
exports.LDMigrationError = LDMigrationError;
/**
 * Class which allows performing technology migrations.
 */
class Migration {
    constructor(client, config) {
        var _a, _b;
        this.client = client;
        this.config = config;
        this.readTable = {
            [api_1.LDMigrationStage.Off]: async (context) => this.doSingleOp(context, 'old', this.config.readOld.bind(this.config)),
            [api_1.LDMigrationStage.DualWrite]: async (context) => this.doSingleOp(context, 'old', this.config.readOld.bind(this.config)),
            [api_1.LDMigrationStage.Shadow]: async (context) => {
                const { fromOld, fromNew } = await this.doRead(context);
                this.trackConsistency(context, fromOld, fromNew);
                return fromOld;
            },
            [api_1.LDMigrationStage.Live]: async (context) => {
                const { fromNew, fromOld } = await this.doRead(context);
                this.trackConsistency(context, fromOld, fromNew);
                return fromNew;
            },
            [api_1.LDMigrationStage.RampDown]: async (context) => this.doSingleOp(context, 'new', this.config.readNew.bind(this.config)),
            [api_1.LDMigrationStage.Complete]: async (context) => this.doSingleOp(context, 'new', this.config.readNew.bind(this.config)),
        };
        this.writeTable = {
            [api_1.LDMigrationStage.Off]: async (context) => ({
                authoritative: await this.doSingleOp(context, 'old', this.config.writeOld.bind(this.config)),
            }),
            [api_1.LDMigrationStage.DualWrite]: async (context) => {
                const fromOld = await this.doSingleOp(context, 'old', this.config.writeOld.bind(this.config));
                if (!fromOld.success) {
                    return {
                        authoritative: fromOld,
                    };
                }
                const fromNew = await this.doSingleOp(context, 'new', this.config.writeNew.bind(this.config));
                return {
                    authoritative: fromOld,
                    nonAuthoritative: fromNew,
                };
            },
            [api_1.LDMigrationStage.Shadow]: async (context) => {
                const fromOld = await this.doSingleOp(context, 'old', this.config.writeOld.bind(this.config));
                if (!fromOld.success) {
                    return {
                        authoritative: fromOld,
                    };
                }
                const fromNew = await this.doSingleOp(context, 'new', this.config.writeNew.bind(this.config));
                return {
                    authoritative: fromOld,
                    nonAuthoritative: fromNew,
                };
            },
            [api_1.LDMigrationStage.Live]: async (context) => {
                const fromNew = await this.doSingleOp(context, 'new', this.config.writeNew.bind(this.config));
                if (!fromNew.success) {
                    return {
                        authoritative: fromNew,
                    };
                }
                const fromOld = await this.doSingleOp(context, 'old', this.config.writeOld.bind(this.config));
                return {
                    authoritative: fromNew,
                    nonAuthoritative: fromOld,
                };
            },
            [api_1.LDMigrationStage.RampDown]: async (context) => {
                const fromNew = await this.doSingleOp(context, 'new', this.config.writeNew.bind(this.config));
                if (!fromNew.success) {
                    return {
                        authoritative: fromNew,
                    };
                }
                const fromOld = await this.doSingleOp(context, 'old', this.config.writeOld.bind(this.config));
                return {
                    authoritative: fromNew,
                    nonAuthoritative: fromOld,
                };
            },
            [api_1.LDMigrationStage.Complete]: async (context) => ({
                authoritative: await this.doSingleOp(context, 'new', this.config.writeNew.bind(this.config)),
            }),
        };
        if (this.config.execution) {
            this.execution = this.config.execution;
        }
        else {
            this.execution = new LDMigrationOptions_1.LDConcurrentExecution();
        }
        this.latencyTracking = (_a = this.config.latencyTracking) !== null && _a !== void 0 ? _a : true;
        this.errorTracking = (_b = this.config.errorTracking) !== null && _b !== void 0 ? _b : true;
    }
    async read(key, context, defaultStage, payload) {
        const stage = await this.client.migrationVariation(key, context, defaultStage);
        const res = await this.readTable[stage.value]({
            payload,
            tracker: stage.tracker,
        });
        stage.tracker.op('read');
        this.sendEvent(stage.tracker);
        return res;
    }
    async write(key, context, defaultStage, payload) {
        const stage = await this.client.migrationVariation(key, context, defaultStage);
        const res = await this.writeTable[stage.value]({
            payload,
            tracker: stage.tracker,
        });
        stage.tracker.op('write');
        this.sendEvent(stage.tracker);
        return res;
    }
    sendEvent(tracker) {
        const event = tracker.createEvent();
        if (event) {
            this.client.trackMigration(event);
        }
    }
    trackConsistency(context, oldValue, newValue) {
        if (!this.config.check) {
            return;
        }
        if (oldValue.success && newValue.success) {
            // Check is validated before this point, so it is force unwrapped.
            context.tracker.consistency(() => this.config.check(oldValue.result, newValue.result));
        }
    }
    async readSequentialFixed(context) {
        const fromOld = await this.doSingleOp(context, 'old', this.config.readOld.bind(this.config));
        const fromNew = await this.doSingleOp(context, 'new', this.config.readNew.bind(this.config));
        return { fromOld, fromNew };
    }
    async readConcurrent(context) {
        const fromOldPromise = this.doSingleOp(context, 'old', this.config.readOld.bind(this.config));
        const fromNewPromise = this.doSingleOp(context, 'new', this.config.readNew.bind(this.config));
        const [fromOld, fromNew] = await Promise.all([fromOldPromise, fromNewPromise]);
        return { fromOld, fromNew };
    }
    async readSequentialRandom(context) {
        // This number is not used for a purpose requiring cryptographic security.
        const randomIndex = Math.floor(Math.random() * 2);
        // Effectively flip a coin and do it on one order or the other.
        if (randomIndex === 0) {
            const fromOld = await this.doSingleOp(context, 'old', this.config.readOld.bind(this.config));
            const fromNew = await this.doSingleOp(context, 'new', this.config.readNew.bind(this.config));
            return { fromOld, fromNew };
        }
        const fromNew = await this.doSingleOp(context, 'new', this.config.readNew.bind(this.config));
        const fromOld = await this.doSingleOp(context, 'old', this.config.readOld.bind(this.config));
        return { fromOld, fromNew };
    }
    async doRead(context) {
        var _a;
        if (((_a = this.execution) === null || _a === void 0 ? void 0 : _a.type) === LDMigrationOptions_1.LDExecution.Serial) {
            const serial = this.execution;
            if (serial.ordering === LDMigrationOptions_1.LDExecutionOrdering.Fixed) {
                return this.readSequentialFixed(context);
            }
            return this.readSequentialRandom(context);
        }
        return this.readConcurrent(context);
    }
    async doSingleOp(context, origin, method) {
        context.tracker.invoked(origin);
        const res = await this.trackLatency(context.tracker, origin, () => safeCall(() => method(context.payload)));
        if (!res.success && this.errorTracking) {
            context.tracker.error(origin);
        }
        return Object.assign({ origin }, res);
    }
    async trackLatency(tracker, origin, method) {
        if (!this.latencyTracking) {
            return method();
        }
        let start;
        let end;
        let result;
        // TODO: Need to validate performance existence check with edge SDKs.
        if (typeof performance !== 'undefined') {
            start = performance.now();
            result = await method();
            end = performance.now();
        }
        else {
            start = Date.now();
            result = await method();
            end = Date.now();
        }
        // Performance timer is in ms, but may have a microsecond resolution
        // fractional component.
        const latency = end - start;
        tracker.latency(origin, latency);
        return result;
    }
}
function createMigration(client, config) {
    return new Migration(client, config);
}
exports.createMigration = createMigration;
//# sourceMappingURL=Migration.js.map