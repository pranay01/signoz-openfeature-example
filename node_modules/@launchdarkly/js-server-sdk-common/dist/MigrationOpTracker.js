"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const js_sdk_common_1 = require("@launchdarkly/js-sdk-common");
const data_1 = require("./api/data");
function isPopulated(data) {
    return !Number.isNaN(data);
}
class MigrationOpTracker {
    constructor(flagKey, contextKeys, defaultStage, stage, reason, checkRatio, variation, version, samplingRatio, logger) {
        this.flagKey = flagKey;
        this.contextKeys = contextKeys;
        this.defaultStage = defaultStage;
        this.stage = stage;
        this.reason = reason;
        this.checkRatio = checkRatio;
        this.variation = variation;
        this.version = version;
        this.samplingRatio = samplingRatio;
        this.logger = logger;
        this.errors = {
            old: false,
            new: false,
        };
        this.wasInvoked = {
            old: false,
            new: false,
        };
        this.consistencyCheck = data_1.LDConsistencyCheck.NotChecked;
        this.latencyMeasurement = {
            old: NaN,
            new: NaN,
        };
    }
    op(op) {
        this.operation = op;
    }
    error(origin) {
        this.errors[origin] = true;
    }
    consistency(check) {
        var _a, _b;
        if (js_sdk_common_1.internal.shouldSample((_a = this.checkRatio) !== null && _a !== void 0 ? _a : 1)) {
            try {
                const res = check();
                this.consistencyCheck = res
                    ? data_1.LDConsistencyCheck.Consistent
                    : data_1.LDConsistencyCheck.Inconsistent;
            }
            catch (exception) {
                (_b = this.logger) === null || _b === void 0 ? void 0 : _b.error('Exception when executing consistency check function for migration' +
                    ` '${this.flagKey}' the consistency check will not be included in the generated migration` +
                    ` op event. Exception: ${exception}`);
            }
        }
    }
    latency(origin, value) {
        this.latencyMeasurement[origin] = value;
    }
    invoked(origin) {
        this.wasInvoked[origin] = true;
    }
    createEvent() {
        var _a, _b, _c, _d, _e;
        if (!js_sdk_common_1.TypeValidators.String.is(this.flagKey) || this.flagKey === '') {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error('The flag key for a migration operation must be a non-empty string.');
            return undefined;
        }
        if (!this.operation) {
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.error('The operation must be set using "op" before an event can be created.');
            return undefined;
        }
        if (Object.keys(this.contextKeys).length === 0) {
            (_c = this.logger) === null || _c === void 0 ? void 0 : _c.error('The migration was not done against a valid context and cannot generate an event.');
            return undefined;
        }
        if (!this.wasInvoked.old && !this.wasInvoked.new) {
            (_d = this.logger) === null || _d === void 0 ? void 0 : _d.error('The migration invoked neither the "old" or "new" implementation and' +
                'an event cannot be generated');
            return undefined;
        }
        if (!this.measurementConsistencyCheck()) {
            return undefined;
        }
        const measurements = [];
        this.populateInvoked(measurements);
        this.populateConsistency(measurements);
        this.populateLatency(measurements);
        this.populateErrors(measurements);
        return {
            kind: 'migration_op',
            operation: this.operation,
            creationDate: Date.now(),
            contextKeys: this.contextKeys,
            evaluation: {
                key: this.flagKey,
                value: this.stage,
                default: this.defaultStage,
                reason: this.reason,
                variation: this.variation,
                version: this.version,
            },
            measurements,
            samplingRatio: (_e = this.samplingRatio) !== null && _e !== void 0 ? _e : 1,
        };
    }
    logTag() {
        return `For migration ${this.operation}-${this.flagKey}:`;
    }
    latencyConsistencyMessage(origin) {
        return `Latency measurement for "${origin}", but "${origin}" was not invoked.`;
    }
    errorConsistencyMessage(origin) {
        return `Error occurred for "${origin}", but "${origin}" was not invoked.`;
    }
    consistencyCheckConsistencyMessage(origin) {
        return (`Consistency check was done, but "${origin}" was not invoked.` +
            'Both "old" and "new" must be invoked to do a consistency check.');
    }
    checkOriginEventConsistency(origin) {
        var _a, _b, _c;
        if (this.wasInvoked[origin]) {
            return true;
        }
        // If the specific origin was not invoked, but it contains measurements, then
        // that is a problem. Check each measurement and log a message if it is present.
        if (!Number.isNaN(this.latencyMeasurement[origin])) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(`${this.logTag()} ${this.latencyConsistencyMessage(origin)}`);
            return false;
        }
        if (this.errors[origin]) {
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.error(`${this.logTag()} ${this.errorConsistencyMessage(origin)}`);
            return false;
        }
        if (this.consistencyCheck !== data_1.LDConsistencyCheck.NotChecked) {
            (_c = this.logger) === null || _c === void 0 ? void 0 : _c.error(`${this.logTag()} ${this.consistencyCheckConsistencyMessage(origin)}`);
            return false;
        }
        return true;
    }
    /**
     * Check that the latency, error, consistency and invoked measurements are self-consistent.
     */
    measurementConsistencyCheck() {
        return this.checkOriginEventConsistency('old') && this.checkOriginEventConsistency('new');
    }
    populateInvoked(measurements) {
        var _a;
        const measurement = {
            key: 'invoked',
            values: {},
        };
        if (!this.wasInvoked.old && !this.wasInvoked.new) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error('Migration op completed without executing any origins (old/new).');
        }
        if (this.wasInvoked.old) {
            measurement.values.old = true;
        }
        if (this.wasInvoked.new) {
            measurement.values.new = true;
        }
        measurements.push(measurement);
    }
    populateConsistency(measurements) {
        var _a;
        if (this.consistencyCheck !== undefined &&
            this.consistencyCheck !== data_1.LDConsistencyCheck.NotChecked) {
            measurements.push({
                key: 'consistent',
                value: this.consistencyCheck === data_1.LDConsistencyCheck.Consistent,
                samplingRatio: (_a = this.checkRatio) !== null && _a !== void 0 ? _a : 1,
            });
        }
    }
    populateErrors(measurements) {
        if (this.errors.new || this.errors.old) {
            const measurement = {
                key: 'error',
                values: {},
            };
            if (this.errors.new) {
                measurement.values.new = true;
            }
            if (this.errors.old) {
                measurement.values.old = true;
            }
            measurements.push(measurement);
        }
    }
    populateLatency(measurements) {
        const newIsPopulated = isPopulated(this.latencyMeasurement.new);
        const oldIsPopulated = isPopulated(this.latencyMeasurement.old);
        if (newIsPopulated || oldIsPopulated) {
            const values = {};
            if (newIsPopulated) {
                values.new = this.latencyMeasurement.new;
            }
            if (oldIsPopulated) {
                values.old = this.latencyMeasurement.old;
            }
            measurements.push({
                key: 'latency_ms',
                values,
            });
        }
    }
}
exports.default = MigrationOpTracker;
//# sourceMappingURL=MigrationOpTracker.js.map